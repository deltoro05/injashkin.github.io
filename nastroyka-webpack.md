---
title: 'Настройка Webpack 5'
description: 'Установим и настроим сборку Webpack v.5, которая позволит создавать статические страницы сайта используя шаблонизатор Pug, препроцессор Sass, язык JavaScript и разметку Markdown'
---

## Что мы сделаем

Установим и настроим Webpack и необходимые модули, которые позволят нам создавать статические страницы сайта используя удобные инструменты:

- Создавать на шаблонизаторе Pug разметку, которая будет автоматически преобразовываться в разметку HTML
- Создавать на препроцессоре Sass стили, которые будут автоматически преобразовываться в стили CSS
- Использовать в JavaScript самые последние достижения языка и при этом не переживать, что какая-то новая функция не будет распознана старым браузером
- Наполнять содержимое страниц сайта с помощью Markdown разметки, которая в конечном итоге будет автоматически преобразована в понятный для браузеров HTML

## Быстрый запуск Webpack

Чтобы выполнять дальнейшие действия у нас на компьютере должен быть установлен [Node.js](https://nodejs.org/).

Откроем терминал и создадим каталог нашего будущего проекта, и сразу перейдем в него:

```
mkdir my-project
cd my-project
```

Теперь, если нам нужна система контроля версий Git, то выполним два простых шага, сначала, инициализируем Git:

```
git init
```

Затем создадим для Git файл `.gitignore`. В этом файле будем указывать игнорируемые файлы и каталоги, которые не должны попадать в коммиты. Запишем в этом файле следующее:

```
node_modules
```

С настройками Git в этом проекте покончено. Теперь не забываем, иногда, делать коммиты.

Инициализируем npm:

```
npm init -y
```

Будет создан файл `package.json` с настройками по умолчанию (на что указывает опция -y). Наиболее полную информацию о файле package.json можно прочитать в [документации по npm](https://docs.npmjs.com/cli/v8/configuring-npm/package-json).

Теперь установим `webpack`, а также `webpack-cli`, который используется для запуска webpack в командной строке).

```
npm i -D webpack webpack-cli
```

Опция `-D` указывает, что устанавливаемые пакеты нужны только для разработки и не будут использоваться в производственной сборке. Это будет зафиксировано в файле `package.json` в секции `"devDependencies": {...}`.

В результате будет создан каталог `node_modules` и файл `package-lock.json`. Каталог `node_modules` содержит все установленные зависимости проекта. Обычно этот каталог не рекомендуется включать в репозитории, что мы и сделали, проигнорировав его в файле `.gitignore`. Файл `package-lock.json` хранит записи о точных версиях установленных зависимостей.
Далее откроем `package.json` и добавим скрипт (строка с плюсом, плюс не добавляем!):

```json
"scripts": {
+ "dev": "webpack --mode development",
  "test": "echo \"Error: no test specified\" && exit 1"
}
```

Данный скрипт позволяет запустить webpack с настройками по умолчанию не создавая файл `webpack.config.js` и не определяя точки входа и выхода приложения. По умолчанию,Webpack будет искать файл `index.js` в каталоге `src` (точка выхода) и выводить откомпилированный код в `dist/main.js` (точка выхода). Чтобы изменить настройки по умолчанию смотри [Настройка точки входа и выхода Webpack](#настройка-точки-входа-и-выхода-webpack).

Создадим для исходного кода в корне проекта каталог `src`, а в нем создадим файл `index.js` со следующим кодом:

```js
function component(text) {
  const element = document.createElement('h1');
  element.textContent = text;
  return element;
}

document.body.append(component('Проект собран на Webpack'));
```

Теперь запустим webpack:

```
npm run dev
```

В результате, в корне проекта появится каталог `dist`, а в нем скомпилированный файл `main.js`. Но сам по себе этот файл бесполезен без HTML-файла, который должен загружать `main.js` в качестве скрипта. Поэтому, в каталоге `dist` создадим файл разметки `index.html` со следующим содержимым:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Быстрый запуск Webpack</title>
  </head>
  <body>
    <p>Данный файл создан вручную</p>
    <script src="main.js"></script>
  </body>
</html>
```

На данный момент файловая структура нашего проекта будет выглядеть так:

```
my-project
  |-dist
    index.html
    main.js
  |+node_modules
  |-src
    index.js
  package.json
  package-lock.json
```

Если теперь мы откроем файл `dist/index.html` в браузере, то увидим следующее:

```
Проект собран на Webpack
```

Недостаток этого метода очевиден, нам приходится вручную "допиливать" готовую сборку, чтобы она заработала в браузере. Поэтому, сделаем так, чтобы в готовую сборку HTML-файл собирался из исходного шаблона. Для этого используем html-webpack-plugin.

## Установка и настройка html-webpack-plugin

Установим плагин:

```
npm i -D html-webpack-plugin
```

Теперь настроим html-webpack-plugin. Для этого создадим в корне проекта файл `webpack.config.js` и заполним его следующим содержимым.

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, 'src', 'template.html'),
      filename: 'index.html',
    }),
  ],
};
```

Файл настроек `webpack.config.js` нужен вебпаку для того, чтобы он знал, какие плагины и с какими настройками использовать в том или ином случае.

Пояснение к содержимому файла `webpack.config.js`:

- Первые две строки импортируют модули `html-webpack-plugin` и `path`, определяя их в переменные `HtmlWebpackPlugin` и `path` соответственно.

- `module.exports = {}` - это объект, который экспортируется как модуль по умолчанию.

- Для плагина `html-webpack-plugin` создается экземпляр `new HtmlWebpackPlugin`, для которого заданы два свойства: `template` - путь к входному файлу и `filename` - имя выходного файла.

Разберем путь, указанный в свойстве `template`, который, на первый взгляд, сложен для понимания.

В Linux и macOS пути выглядят так: `/path/to/template.html`. В Windows пути имеют другой вид: `C:\path\to\template.html`. Для работы с путями в Node.js имеется модуль `path`, который учитывает эти различия. Мы его подключили во второй строке файла `webpack.config.js`, а затем вызвали в свойстве `template`. В модуле `path` есть метод `join`, который объединяет все заданные сегменты пути вместе и использует необходимый разделитель для конкретной системы. Сегменты пути для метода `path.join` мы задали тремя аргументами `__dirname`, `'src'` и `'template.html'`.

- `__dirname` - это глобальная константа, которая указывает абсолютный путь к каталогу файла, код которого запрашивает эту константу, т. е. в нашем случае, этим файлом является `webpack.config.js`, а `__dirname` содержит абсолютный путь к корневому каталогу проекта.

В каталоге `src` создадим входной файл `template.html` с такой разметкой:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Быстрый запуск Webpack</title>
  </head>
  <body>
    <p>Данный файл создан плагином html-webpack-plugin</p>
  </body>
</html>
```

Теперь удалим каталог `dist` с двумя содержащимися в нем файлами. Откроем терминал в корне проекта и запустим команду:

```
npm run dev
```

Мы увидим, что каталог `dist` снова создан, а внутри него находятся файлы `index.html` и `main.js`. Если мы откроем в браузере файл `dist/index.html`, то увидим:

```
Проект собран на Webpack
Данный файл создан плагином html-webpack-plugin
```

Таким образом, с помощью плагина html-webpack-plugin из исходного файла `src/template.html` был создан html-файл `dist/index.html`, в котором подключен скрипт `dist/main.js`, а он, в свою очередь, создан из `src/index.js`.

Теперь мы можем разрабатывать свой проект придерживаясь следующих шагов:

1. Редактируем исходный код в любом из файлов каталога `src`
2. Сохраняем результат
3. Выполняем сборку проекта:

```
npm run dev
```

4. Открываем в браузере файл `dist/index.html`, либо если этот файл уже открыт, перезагружаем страницу браузера.
5. Смотрим на полученный результат в браузере и если нас что-то не устраивает повторяем все пункты сначала.

## Установка и настройка DevServer

После очередного изменения кода, чтобы увидеть скомпилированный результат, нужно каждый раз запускать в терминале команду `npm run dev` и вручную обновлять страницу браузера. Это очень быстро надоедает.

В webpack доступно три способа, которые помогут автоматически компилировать код всякий раз, когда вы его сохраняете:

1. [Режим Watch](https://webpack.js.org/guides/development/#using-watch-mode)
2. [webpack-dev-server](https://webpack.js.org/guides/development/#using-webpack-dev-server)
3. [webpack-dev-middleware](https://webpack.js.org/guides/development/#using-webpack-dev-middleware)

Здесь рассмотрим вариант с веб сервером. Установим webpack-dev-server:

```
npm i -D webpack-dev-server
```

Откроем файл `webpack.config.js` и добавим настройки для веб сервера:

```js
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, 'src', 'template.html'),
      filename: 'index.html',
    }),
  ],
  devServer: {
    watchFiles: path.join(__dirname, 'src'),
    port: 9000,
  },
};
```

Для `devServer` указаны два свойства:

- `watchFiles` указывает на каталог `src`, за которыми будет вестись наблюдение и в случае, если в нем произойдут изменения, веб сервер будет автоматически пересобирать проект и перезагружать страницу браузера.
- `port` указывает порт на котором будет работать веб-сервер (по умолчанию - localhost:8080).

Чтобы запускать веб сервер короткой командой напишем скрипт "serve":

**package.json**

```json
{
  "scripts": {
+   "serve": "webpack serve --open --mode development",
    "dev": "webpack --mode development",
    "test": "echo \"Error: no test specified\" && exit 1"
  }
}
```

`serve` означает запустить веб сервер. [`--open`](https://webpack.js.org/configuration/dev-server/#devserveropen) автоматически запускает браузер по умолчанию. `--mode development` включает режим разработки.

Перед тем как запустить веб сервер удалим каталог `dist` (это делать необязательно, а нужно для того, чтобы понять работу веб-сервера).

Запустим веб сервер командой:

```
npm run serve
```

В результате будет открыта страница браузера по адресу http://localhost:9000/ и мы увидим тоже самое, что и в прошлый раз:

```
Проект собран на Webpack
Данный файл создан плагином html-webpack-plugin
```

Но, если мы посмотрим на файловую структуру проекта, то не увидим, каталога `dist`. Тогда откуда браузер берет данные для вывода?

Нужно понимать, что webpack-dev-server компилирует исходный код, и записывает все файлы в оперативную память.

Теперь файловая структура нашего проекта будет выглядеть так:

```
my-project
  |-node_modules
  |-src
    index.js
    template.html
  package-lock.json
  package.json
  webpack.config.js
```

Чтобы остановить веб сервер нужно в терминале, в котором запущен сервер, нажать сочетание клавиш Ctrl+C.

## Настройка точки входа и выхода Webpack

Начиная с четвертой версии Webpack позволяет не задавать точки входа и выхода, а использовать настройки по умолчанию: точка входа - `./src/index.js` и точка выхода - `./dest/main.js`.

### Точка входа

**Точка входа** - это файл, который вебпак начнет компилировать первым и если в этом файле будут подключены какие-нибудь зависимости, то все они тоже будут обработаны.

Мы не будем менять существующую в нашем проекте точку входа, а лишь зададим в настройках возможность, в дальнейшем, быстро это сделать. Для этого откроем файл `webpack.config.js` и добавим свойство `entry`:

```js
module.exports = {
  entry: path.join(__dirname, 'src', 'index.js'),
};
```

Теперь, если нам нужно будет изменить точку входа мы изменяем значение свойства `entry`. Также, можно задать несколько точек входа. Более подробно о настройках точки входа можно прочитать в статье [Entry Points](https://webpack.js.org/concepts/entry-points/).

### Точка выхода

**Точка выхода** - это каталог, в который вебпак скомпилирует все точки входа.

Чтобы настроить точку выхода, нужно в файл `webpack.config.js` добавить свойство `output`:

```js
module.exports = {
  output: {
    filename: '[name].js',
    path: path.join(__dirname, 'dist'),
  },
};
```

где:

- `[name]` - это шаблонная [подстановка](https://webpack.js.org/configuration/output/#outputfilename) имени. В данном случае она равна имени `index` из имени файла точки входа. Так как точек входа может быть несколько, то `[name]` позволяет сохранить свое уникальное имя для каждого файла.

Более полная информация о точках выхода приведена в статье [Output](https://webpack.js.org/concepts/output/).

Теперь файл `webpack.config.js` должен выглядеть так:

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: path.join(__dirname, 'src', 'index.js'),
  output: {
    filename: '[name].js',
    path: path.join(__dirname, 'dist'),
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, 'src', 'template.html'),
      filename: 'index.html',
    }),
  ],
  devServer: {
    watchFiles: path.join(__dirname, 'src'),
    port: 9000,
  },
};
```

Запустим из терминала следующую команду:

```
npm run dev
```

В корне проекта появится каталог `dist`, в котором будут находиться два файла: `index.html` и `index.js`. Мы видим что, файл `index.js` имеет такое же имя, что и исходный файл в каталоге `src`, указанный как точка входа.

## Настройка режима production и создание производственной сборки

До сих пор мы работали с вебпаком в режиме разработки. Но чтобы получить готовое приложение, которое можно разместить на удаленном сервере, нужно создать производственную сборку.

Откроем файл `package.json` и добавим скрипт `"build"`:

```json
  "scripts": {
    "serve": "webpack serve --open --mode development",
    "dev": "webpack --mode development",
+   "build": "webpack --mode production",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
```

Теперь, прежде чем выполнить нужную команду, откроем файл `dist/index.js` в редакторе кода и посмотрим на него. Мы увидим кучу различных комментариев и код представлен не в сжатом виде, а если мы посмотрим на размер файла, то он составит примерно 1 424 байта. Затем, в терминале запустим вебпак в режиме продакшн:

```
npm run build
```

После этого, посмотрим на содержимое файла `dist/index.js`, в котором увидим отсутствие комментариев и сжатый код. Размер самого файла составит 139 байт. Это основное отличие режима продакшн от режима разработки - код конечного бандла сжимается. То же относится и к файлу `index.html`, который в режиме разработки не сжимается и его размер составлял 273 байта, а в продакшн режиме убираются все пробелы и ненужные символы и размер стал равен 250 байт.

## Подключение шаблонизатора Pug

Верстка на чистом HTML не совсем удобна в плане синтаксиса при написания разметки и поддержки больших проектов. Придуманы более удобные инструменты, которые называются шаблонизаторами.

Шаблонизаторы позволяют:

- создавать шаблоны, компоненты, блоки
- работать с данными, подставляя эти данные в код. Так, имея компонент для карточки товара, и подставляя данные в этот компонент из объекта JSON, шаблонизатор может автоматически создать огромное количество карточек. Также меняя данные можно менять классы, что позволяет управлять интерфейсом компонентов.
- задавать условные выражения и циклы, как в языках программирования.

Одним из таких инструментов является [шаблонизатор Pug](https://pugjs.org/). Он написан на JavaScript и выполняется в среде Node.js. Шаблонизатор Pug имеет свой синтаксис, на котором пишется разметка. Этот синтаксис основан на отступах и отличается от синтаксиса HTML отсутствием угловых скобок и закрывающихся тегов. После компиляции синтаксис Pug превращается в HTML код.

Webpack имеет плагин и загрузчик файлов для шаблонизатора Pug. Это позволяет полноценно использовать Pug для написания HTML разметки.

Установим pug и pug-loader

```
npm i -D pug pug-loader
```

Вебпаку в его конфиг файле укажем, что мы используем загрузчик pug-loader для файлов с расширением .pug:

**webpack.config.js**

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
+ module: {
+   rules: [
+     {
+       test: /\.pug$/,
+       loader: 'pug-loader',
+     },
+   ],
+ },
  plugins: [
    new HtmlWebpackPlugin({
+     template: './src/index.pug',
      filename: 'index.html',
    }),
  ],
  devServer: {
    watchFiles: './src',
    port: 9000,
  },
};
```

Создадим файл ./src/index.pug и напишем в нем следующее:

```pug
html
  head
    meta(charset='utf-8')
    title= 'Быстрый запуск Webpack'
  body
    p Данный файл откомпилирован шаблонизатором Pug
```

Файл `src/template.html` теперь можно удалить.

Запустим в терминале знакомую нам команду:

```
npm run serve
```

Будет открыта страница браузера по адресу http://localhost:9000/ и мы увидим:

```
Проект собран на Webpack
Данный файл откомпилирован шаблонизатором Pug
```

## Babel

Babel позволяет писать код с использованием новых возможностей JavaScript ES6 и ES7. При этом мы можем не заботится о том, что какая-то функция не будет поддерживаться каким-либо браузером. Babel транспилирует код, который еще не поддерживается, обратно в ванильный JavaScript. Для работы самого Babel нужно установить два пакета `@babel/core` и `@babel/preset-env`, а чтобы Webpack мог работать с Babel нужно установить загрузчик `babel-loader`. Установим все три пакета одной командой:

```
npm i -D @babel/core @babel/preset-env babel-loader
```

Все конфиги для Babel можно указывать в файле `.babelrc`. Создадим этот файл в корне проекта:

```
touch .babelrc
```

## Загрузка стилей

Для написания стилей мы будем использовать препроцессор Sass. А чтобы большинство браузеров понимало самые современные возможности CSS, которые мы будем применять для стилизации, мы будем прогонять CSS через PostCSS.

Установим необходимые загрузчики:

```
npm i -D sass-loader postcss-loader postcss-preset-env css-loader style-loader node-sass
```

Настройки для PostCSS можно задать как в файле webpack.config.js так и в собственном файле настроек postcss.config.js:

**./postcss.config.js**

```js
module.exports = {
  plugins: {
    'postcss-preset-env': {
      browsers: 'last 2 versions',
    },
  },
};
```

Создадим файл ./src/main.scss. В файле будут переменные Sass, а также [LCH цвета](https://habr.com/ru/company/ruvds/blog/496966/), которые поддерживаются не всеми браузерами, но используя PostCSS эти цвета будут транспилированы в понятные любому браузеру цвета.

**./src/main.scss**

```scss
$font-size: 1rem;
$font-color: lch(28 99 35);

html {
  font-size: $font-size;
  color: $font-color;
}
```

Импортируем этот файл в ./src/index.js:

**./src/index.js**

```js
import './main.scss';
```

Такой импорт стилей в скрипт возможен только благодаря загрузчикам стилей webpack.

Указываем вебпаку, какие загрузчики стилей применять. Причем, порядок их перечисления в массиве важен, так как загрузчики используются вебпаком от последнего к первому:

1. Так что последним в списке должен быть sass-loader, который загружает файлы SCSS и компилирует его в CSS.

2. Затем идет postcss-loader, который с помощью [PostCSS](https://postcss.org/) транспилирует самые современные фичи CSS (переменные, миксины и многое другое) в то, что понятно большинству браузеров. Также, PostCSS применяет автопрефиксер и линтер к CSS.

3. Следующим в списке будет css-loader, который интерпретирует @import и url() внутри CSS.

4. Последним является style-loader, который внедряет CSS в DOM

**webpack.config.js**

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  module: {
    rules: [
      {
        test: /\.pug$/,
        loader: 'pug-loader',
      },
+     // CSS, PostCSS, Sass
+     {
+       test: /\.(scss|css)$/,
+       use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'],
+     },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.pug', // входной файл
      filename: 'index.html', // выходной файл
    }),
  ],
  devServer: {
    watchFiles: './src',
    port: 9000,
  },
};
```

Запустим в терминале команду:

```
npm run serve
```

Откроется браузер и мы увидим окрашенный в цвет текст.

## Загрузка изображений

Начиная с webpack 5, вместо загрузчиков для рисунков, значков, шрифтов и т. д. используется встроенный [Asset Modules](https://webpack.js.org/guides/asset-modules/). Для поддержки рисунков настроим webpack.config.js:

**webpack.config.js**

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  module: {
    rules: [
      {
        test: /\.pug$/,
        loader: 'pug-loader',
      },
      // CSS, PostCSS, Sass
      {
        test: /\.(scss|css)$/,
        use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'],
      },
+     {
+       test: /\.(png|svg|jpg|jpeg|gif)$/i,
+       type: 'asset/resource',
+     },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.pug', // входной файл
      filename: 'index.html', // выходной файл
    }),
  ],
  devServer: {
    watchFiles: './src',
    port: 9000,
  },
};
```

Создадим каталог ./src/images и поместим в него файл image.jpg

Откроем ранее созданный файл ./src/index.pug и допишем в нем следующее:

**./src/index.pug**

```pug
doctype html
html(lang= 'ru')
  head
    meta(charset='utf-8')
    title= 'Быстрый запуск Webpack'
  body
+   img(src=require('./images/image.jpg') alt='Загрузка изображений с помощью Webpack')
```

## Включение синтаксиса Markdown и файлов .md в Pug

Если мы хотим использовать Markdown в шаблонизаторе Pug, то для этого можно применить фильтр `:markdown-it` модуля [jstransformer-markdown-it](https://github.com/jstransformers/jstransformer-markdown-it).

[Фильтры](https://pugjs.org/language/filters.html) позволяют использовать в шаблонизаторе Pug многие другие языки, а также написать собственные фильтры. Для начала установим модуль `jstransformer-markdown-it`:

```
$ npm i -D jstransformer-markdown-it
```

Теперь мы можем в Pug файле использовать синтаксис Markdown:

```pug
:markdown-it(linkify langPrefix='highlight-')
  # Markdown

  Markdown document with http://links.com
```

либо включить в шаблон внешний файл `.md`, используя `include`:

```pug
include:markdown-it article.md
```

## Другие плагины

- **mini-css-extract-plugin** - этот плагин извлекает CSS в отдельные файлы. Он создает файл CSS для каждого файла JS, который содержит CSS.
