<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/index.1gg5pvr4d.css">
    <script defer src="/index.1gg5pvr4d.js"></script>
    <meta name="description" content="Это второй урок из серии “Руководство по Gatsby” и является вольным переводом официального источника">
    <title>Руководство по Gatsby | jinv.ru</title>
    <link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="images/icons/icon57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/icons/icon60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/icons/icon72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/icons/icon76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/icons/icon114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/icons/icon120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/icons/icon144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/icons/icon152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/icons/icon180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="images/icons/icon192.png">
    <link rel="icon" href="images/icons/icon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="images/icons/icon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="images/icons/icon96.png" type="image/png" sizes="96x96">
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="stylesheet" href="/highlight/vs2015.min.css">
    <script src="/highlight/highlight.min.js">   </script>
    <script>hljs.configure({noHighlightRe: language-perl})</script>
    <script>hljs.highlightAll()</script>
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/icons/icon144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <header class="header">
      <div class="header__content content">           
        <div class="header__logo">
          <div class="logo">        <a href="/" title="jinv.ru"> 
              <svg class="icon icon__logo" role="img" width="14em" height="5em">
                <use href="/sprite.svg#logo"></use>
              </svg></a></div>
          <div class="logo_mobile"><a href="/" title="jinv.ru"><img src="/images/icon-72x72.png" alt="Логотип сайта jinv.ru"/></a></div>
        </div>
        <nav class="menu" aria-label="Главное меню">   
          <div class="content"> 
            <input id="menu__toggle" type="checkbox"/>
            <label class="menu__btn" for="menu__toggle"><span>   </span></label>
            <ul class="menu__box">
              <li><a class="menu__item" href="/">Главная</a></li>
              <li><a class="menu__item" href="/toc.html">Статьи</a></li>
              <li><a class="menu__item" href="/author.html">Об авторе</a></li>
            </ul>
          </div>
        </nav>
        <div class="theme">
          <select id="theme" name="theme">        
            <option value="auto">Авто      </option>
            <option value="light">Светлая      </option>
            <option value="dark">Темная    </option>
          </select>
        </div>
        <div class="header__contacts">
          <div class="send-mes">
            <div class="soc"><a class="mes-tg" href="https://t.me/jashkin" title="Telegram" target="_blank" rel="nofollow">
                <svg class="icon icon__telegram" role="img" width="1em" height="1em">
                  <use href="/sprite.svg#telegram"></use>
                </svg></a><a class="mes-wa" href="https://api.whatsapp.com/send?phone=79183549497" title="WhatsApp" target="_blank" rel="nofollow">
                <svg class="icon icon__whatsapp" role="img" width="1em" height="1em">
                  <use href="/sprite.svg#whatsapp"></use>
                </svg></a>
            </div>
          </div>
          <div class="contacts">         
            <p> <a href="https://github.com/injashkin/injashkin.github.io">Github</a></p>
          </div>
        </div>
      </div>
    </header>
    <div class="content">
      <div class="article">
        <h1>Руководство по Gatsby</h1>
        <div class="creationDate">Создано: 06-02-2020</div><h2>1. Знакомство со строительными блоками Gatsby</h2>
<p>Это второй урок из серии “Руководство по Gatsby” и является вольным переводом <a href="https://www.gatsbyjs.org/tutorial">официального источника</a></p>
<p>В <a href="https://jinv.ru/gatsby/nastrojka-sredy-razrabotki-dlya-frejmvorka-gatsby/">предыдущем разделе</a> вы подготовили локальную среду разработки, установив необходимое программное обеспечение и создав свой первый сайт Gatsby с помощью <a href="https://github.com/gatsbyjs/gatsby-starter-hello-world">стартера “hello world”</a>. Теперь погрузитесь глубже в код, сгенерированный этим стартером.</p>
<h3>Использование стартеров Gatsby</h3>
<p>В <a href="../nastrojka-sredy-razrabotki-dlya-frejmvorka-gatsby">нулевой части</a> учебника вы создали новый сайт на основе стартера &quot;hello world&quot;, используя следующую команду:</p>
<pre><code>gatsby new hello-world https://github.com/gatsbyjs/gatsby-starter-hello-world
</code></pre>
<p>При создании нового сайта на Gatsby можно использовать следующую структуру команд для создания нового сайта на основе любого существующего стартера Gatsby:</p>
<pre><code>gatsby new [SITE_DIRECTORY_NAME] [URL_OF_STARTER_GITHUB_REPO]
</code></pre>
<p>Если вы опустите URL-адрес в конце, Gatsby автоматически создаст сайт для вас на основе стартера по умолчанию. Для этого раздела учебника придерживайтесь сайта ”Hello World&quot;, который вы уже создали в нулевой части учебника. Вы можете узнать больше об <a href="https://www.gatsbyjs.org/docs/modifying-a-starter">изменении стартеров</a> в документации.</p>
<h3>Знакомство со страницами Gatsby</h3>
<p>Откройте каталог <code>/src</code> в редакторе кода. Внутри находится один каталог: <code>/pages</code>.</p>
<p>Откройте файл по адресу <code>src/pages/index.js</code>. Код в этом файле создает компонент, который содержит один div и некоторый текст - соответственно, &quot;Hello world!”</p>
<p>Gatsby использует горячую перезагрузку, чтобы ускорить процесс разработки. По сути, при запущенном сервере разработки Gatsby, каждый раз, когда вы сохраняете файл, файлы сайта Gatsby “просматриваются&quot; в фоновом режиме и ваши изменения немедленно отображаются в браузере. Вам не нужно вручную обновлять страницу или перезапускать сервер разработки.</p>
<h2>Данные в Gatsby</h2>
<p>В следующих четырех частях учебника (включая эту) вы погрузитесь в слой данных Gatsby, который является мощной функцией Gatsby, которая позволяет легко создавать сайты из Markdown, WordPress, headless CMSs и других источников данных всех вкусов.</p>
<p>Слой данных Gatsby работает на GraphQL. О GraphQL можно прочитать статью <a href="https://www.howtographql.com/">Как использовать GraphQL</a>.</p>
<p>Веб-сайт состоит из четырех частей: HTML, CSS, JS и данных. Давайте узнаем, как использовать данные на сайтах Гэтсби.</p>
<p>Что такое данные?</p>
<p>Очень компьютерный ответ был бы: данные - это такие вещи, как &quot;строки&quot;, целые числа (42), объекты ({ pizza: true}) и т. д.</p>
<p>Для целей работы в Гэтсби, однако, более полезным ответом является “все, что живет вне компонента React&quot;.</p>
<p>До сих пор вы писали текст и добавляли изображения непосредственно в компоненты. Что является отличным способом для создания многих веб-сайтов. Но часто требуется хранить данные вне компонентов, а затем вносить их в компонент по мере необходимости.</p>
<p>Если вы создаете сайт с помощью WordPress (так что у других участников есть хороший интерфейс для добавления и поддержания контента) и Gatsby, данные для сайта (страницы и сообщения) находятся в WordPress, и вы по мере необходимости извлекаете эти данные в свои компоненты.</p>
<p>Данные также могут находиться в таких типах файлов, как Markdown, CSV и т. д. а также базы данных и API всех видов.</p>
<p>Слой данных Гэтсби позволяет извлекать данные из этих (и любых других источников) непосредственно в ваши компоненты — в нужной вам форме.</p>
<h3>Использование неструктурированных данных или GraphQL</h3>
<p>Обязатеьно ли использовать GraphQL и плагины source для извлечения данных на сайты Gatsby?</p>
<p>Необязательно! Вы можете использовать API <code>createPages</code> для извлечения неструктурированных данных на страницы Gatsby напрямую, а не через слой данных GraphQL. Это отличный выбор для небольших сайтов, в то время как GraphQL и исходные плагины могут помочь сэкономить время на более сложных сайтах.</p>
<p>Смотрите руководство <a href="https://www.gatsbyjs.org/docs/using-gatsby-without-graphql/">Using Gatsby without GraphQL</a>, чтобы узнать, как получить данные на ваш Gatsby сайт с помощью API node <code>createPages</code> и посмотреть пример сайта!</p>
<p>Когда использовать неструктурированные данные, а когда GraphQL?</p>
<p>Если вы создаете небольшой сайт, одним из эффективных способов его создания является извлечение неструктурированных данных, как описано в этом руководстве, с помощью API <code>createPages</code>, а затем, если сайт становится более сложным, вы переходите к созданию более сложных сайтов, или вы хотите преобразовать свои данные, выполните следующие действия:</p>
<ol>
<li>
<p>Проверьте <a href="https://www.gatsbyjs.org/plugins/">Библиотеку плагинов</a>, чтобы узнать, существуют ли исходники плагинов и/или преобразованные плагины, которые вы хотите использовать</p>
</li>
<li>
<p>Если их нет, прочитайте руководство по разработке плагинов и подумайте о создании собственного!</p>
</li>
</ol>
<h3>Как слой данных Gatsby использует GraphQL для извлечения данных в компоненты</h3>
<p>Существует множество вариантов загрузки данных в компоненты React. Одной из самых популярных и мощных из них является технология <a href="http://graphql.org/">GraphQL</a>.</p>
<p>GraphQL был изобретен в Facebook, чтобы помочь инженерам продукта собрать необходимые данные в компоненты.</p>
<p>GraphQL - это язык запросов (QL-query language). Если вы знакомы с SQL, он работает очень похожим образом. Используя специальный синтаксис, вы описываете нужные данные в компоненте, а затем эти данные передаются вам.</p>
<p>Gatsby использует GraphQL, чтобы позволить компонентам объявлять необходимые им данные.</p>
<h3>Создание нового примера сайта</h3>
<p>Создайте еще один новый сайт для этой части руководства. Вы собираетесь создать блог Markdown под названием &quot;Панды едят много&quot;. Он посвящен демонстрации лучших фотографий и видео панд, поедающих много пищи. По пути вы будете погружать пальцы ног в GraphQL и поддержку Markdown от Gatsby.</p>
<p>Откройте новое окно терминала и выполните следующие команды, чтобы создать новый сайт Гэтсби в каталоге под названием <code>tutorial-part-four</code>. Затем перейдите в новый каталог:</p>
<pre><code>gatsby new tutorial-part-four https://github.com/gatsbyjs/gatsby-starter-hello-world

cd tutorial-part-four
</code></pre>
<p>Затем установите некоторые другие необходимые зависимости в корне проекта. Вы будете использовать тему Typography &quot;Kirkham&quot;, и вы попробуете библиотеку CSS-in-JS, <a href="https://emotion.sh/">&quot;Emotion”</a>:</p>
<pre><code>npm install --save gatsby-plugin-typography typography react-typography typography-theme-kirkham gatsby-plugin-emotion @emotion/core
</code></pre>
<p>Создайте сайт, подобный тому, что вы закончили в третьей части. Этот сайт будет иметь компонент макета и два компонента страницы:</p>
<p>src/components/layout.js</p>
<pre><code class="language-jsx">import React from 'react';
import { css } from '@emotion/core';
import { Link } from 'gatsby';

import { rhythm } from '../utils/typography';

export default ({ children }) =&gt; (
  &lt;div
    css={css`
      margin: 0 auto;
      max-width: 700px;
      padding: ${rhythm(2)};
      padding-top: ${rhythm(1.5)};
    `}
  &gt;
    &lt;Link to={`/`}&gt;
      &lt;h3
        css={css`
          margin-bottom: ${rhythm(2)};
          display: inline-block;
          font-style: normal;
        `}
      &gt;
        Pandas Eating Lots
      &lt;/h3&gt;
    &lt;/Link&gt;
    &lt;Link
      to={`/about/`}
      css={css`
        float: right;
      `}
    &gt;
      About
    &lt;/Link&gt;
    {children}
  &lt;/div&gt;
);
</code></pre>
<p>src/pages/index.js</p>
<pre><code class="language-jsx">import React from 'react';
import Layout from '../components/layout';

export default () =&gt; (
  &lt;Layout&gt;
    &lt;h1&gt;Amazing Pandas Eating Things&lt;/h1&gt;
    &lt;div&gt;
      &lt;img
        src=&quot;https://2.bp.blogspot.com/-BMP2l6Hwvp4/TiAxeGx4CTI/AAAAAAAAD_M/XlC_mY3SoEw/s1600/panda-group-eating-bamboo.jpg&quot;
        alt=&quot;Group of pandas eating bamboo&quot;
      /&gt;
    &lt;/div&gt;
  &lt;/Layout&gt;
);
</code></pre>
<p>src/pages/about.js</p>
<pre><code class="language-jsx">import React from 'react';
import Layout from '../components/layout';

export default () =&gt; (
  &lt;Layout&gt;
    &lt;h1&gt;About Pandas Eating Lots&lt;/h1&gt;
    &lt;p&gt;
      We're the only site running on your computer dedicated to showing the best
      photos and videos of pandas eating lots of food.
    &lt;/p&gt;
  &lt;/Layout&gt;
);
</code></pre>
<p>src/utils/typography.js</p>
<pre><code class="language-jsx">import Typography from 'typography';
import kirkhamTheme from 'typography-theme-kirkham';

const typography = new Typography(kirkhamTheme);

export default typography;
export const rhythm = typography.rhythm;
</code></pre>
<p>gatsby-config.js</p>
<pre><code class="language-jsx">module.exports = {
  plugins: [
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
};
</code></pre>
<p>Добавьте вышеуказанные файлы, а затем запустите команду <code>gatsby develop</code>, как обычно, и вы увидите следующее:</p>
<p><img src="pandas.png" alt="Сайт о пандах"></p>
<h3>Ваш первый запрос GraphQL</h3>
<p>При создании сайтов вы, вероятно, захотите повторно использовать общие части данных — например, название сайта. Посмотрите на страницу <code>/about/</code>. Вы заметите, что у вас есть название сайта (Панды много едят) как в компоненте макета (заголовок сайта), так и в тэге <code>&lt;h1 /&gt;</code> страницы <code>about.js</code> (заголовок страницы).</p>
<p>Но что делать, если вы захотите изменить название сайта? Вам придется искать заголовок во всех ваших компонентах и редактировать каждый экземпляр. Это одновременно громоздко и подвержено ошибкам, особенно для больших и более сложных сайтов. Вместо этого вы можете хранить заголовок в одном месте и ссылаться на него из других файлов; измените заголовок в одном месте, и Gatsby извлечет ваш обновленный заголовок в файлы, которые ссылаются на него.</p>
<p>Местом для этих общих частей данных является объект <code>siteMetadata</code> в файле <code>gatsby-config.js</code>. Добавьте название вашего сайта в файл <code>gatsby-config.js</code>:</p>
<p>gatsby-config.js</p>
<pre><code class="language-js">module.exports = {
  siteMetadata: {
    title: `Title from siteMetadata`,
  },
  plugins: [
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
};
</code></pre>
<p>Перезагрузите сервер разработки.</p>
<h3>Использование запроса страницы</h3>
<p>Теперь название сайта доступно для запроса. Добавьте его в файл <code>about.js</code> используя <a href="https://www.gatsbyjs.org/docs/page-query">запрос страницы</a>:</p>
<p>src/pages/about.js</p>
<pre><code class="language-jsx">import React from 'react';
import { graphql } from 'gatsby';
import Layout from '../components/layout';

export default ({ data }) =&gt; (
  &lt;Layout&gt;
    &lt;h1&gt;About {data.site.siteMetadata.title}&lt;/h1&gt;
    &lt;p&gt;
      We're the only site running on your computer dedicated to showing the best
      photos and videos of pandas eating lots of food.
    &lt;/p&gt;
  &lt;/Layout&gt;
);

export const query = graphql`
  query {
    site {
      siteMetadata {
        title
      }
    }
  }
`;
</code></pre>
<p>Сохраните файл и вы увидите следующее:</p>
<p><img src="about.png" alt="Извлечение заголовка страницы из siteMetadata"></p>
<h3>Использование StaticQuery</h3>
<p><a href="https://www.gatsbyjs.org/docs/static-query/">StaticQuery</a> - это новый API, добавленный в Gatsby v2, который позволяет безстраничным (non-page) компонентам (подобно компоненту layout.js) извлекать данные с помощью запросов GraphQL. Давайте использовать эту недавно введенную версию хука — <a href="https://www.gatsbyjs.org/docs/use-static-query/">useStaticQuery</a>.</p>
<p>Внесите некоторые изменения в файл src/components/layout.js для использования хука <code>useStaticQuery</code> и ссылки {data.site.siteMetadata.title}, которая использует эти данные. Когда вы закончите, ваш файл будет выглядеть следующим образом:</p>
<p>src/components/layout.js</p>
<pre><code class="language-jsx">import React from 'react';
import { css } from '@emotion/core';
import { useStaticQuery, Link, graphql } from 'gatsby';

import { rhythm } from '../utils/typography';
export default ({ children }) =&gt; {
  const data = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            title
          }
        }
      }
    `
  );
  return (
    &lt;div
      css={css`
        margin: 0 auto;
        max-width: 700px;
        padding: ${rhythm(2)};
        padding-top: ${rhythm(1.5)};
      `}
    &gt;
      &lt;Link to={`/`}&gt;
        &lt;h3
          css={css`
            margin-bottom: ${rhythm(2)};
            display: inline-block;
            font-style: normal;
          `}
        &gt;
          {data.site.siteMetadata.title}
        &lt;/h3&gt;
      &lt;/Link&gt;
      &lt;Link
        to={`/about/`}
        css={css`
          float: right;
        `}
      &gt;
        О сайте
      &lt;/Link&gt;
      {children}
    &lt;/div&gt;
  );
};
</code></pre>
<p>Зачем использовать здесь два разных запроса? Эти примеры были кратким введением в типы запросов, как они форматируются и где их можно использовать. А пока имейте в виду, что запросы к страницам могут делать только страницы. Нестраничные компоненты, такие как Layout, могут использовать StaticQuery. Часть 7 учебника объясняет их более подробно.</p>
<p>Один из основных принципов Gatsby заключается в том, что <em>создатели нуждаются в непосредственной связи с тем, что они создают</em> (<a href="http://blog.ezyang.com/2012/02/transcript-of-inventing-on-principle/">hat tip to Bret Victor</a>). Другими словами, когда вы вносите какие-либо изменения в код, вы должны немедленно увидеть эффект этого изменения. Вы манипулируете входными данными Gatsby и видите на экране новый вывод.</p>
<h2>Плагины Source</h2>
<p>Из этого туториала вы узнаете, как использовать GraphQL и плагины source для загрузки данных на сайт Gatsby. Однако прежде чем вы узнаете об этих плагинах, вы должны знать, как использовать инструмент GraphiQL, который поможет вам правильно структурировать ваши запросы.</p>
<h3>Введение в GraphiQL</h3>
<p>GraphiQL - это интегрированная среда разработки (IDE) GraphQL. Это мощный инструмент, который вы будете часто использовать при создании веб-сайтов Гэтсби.</p>
<p>Вы можете получить к нему доступ, когда сервер разработки вашего сайта работает - обычно на http://localhost:8000/___graphql.</p>
<p>Просмотрите встроенный сайт “тип” и посмотрите, какие поля доступны на нем — включая объект siteMetadata, который вы запрашивали ранее. Попробуйте открыть GraphiQL и поиграть с вашими данными! Нажмите Ctrl + Space (или используйте Shift + Space в качестве альтернативного сочетания клавиш), чтобы открыть окно автозаполнения, и Ctrl + Enter, чтобы запустить запрос GraphQL. В оставшейся части урока вы будете использовать GraphiQL намного больше.</p>
<h4>Использование обозревателя GraphiQL</h4>
<p>Обозреватель GraphiQL позволяет интерактивно создавать полные запросы, щелкая по доступным полям и входным данным без повторяющегося процесса ввода этих запросов вручную.</p>
<p>Данные на сайты Gatsby могут поступать из любого места: API, баз данных, CMS, локальных файлов и т. д.</p>
<p>Плагины Source извлекают данные из своего источника. Например, source плагин filesystem знает, как извлечь данные из файловой системы. Плагин WordPress знает, как получить данные из API WordPress.</p>
<p>Добавьте <code>gatsby-source-filesystem</code> и изучите, как он работает.</p>
<p>Во-первых, установите плагин в корень проекта:</p>
<pre><code>npm install --save gatsby-source-filesystem
</code></pre>
<p>Затем добавьте его в файл <code>gatsby-config.js</code>:</p>
<p>gatsby-config.js</p>
<pre><code class="language-js">module.exports = {
  siteMetadata: {
    title: `Pandas Eating Lots`,
  },
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `src`,
        path: `${__dirname}/src/`,
      },
    },
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
};
</code></pre>
<p>Сохраните это и перезагрузите сервер разработки gatsby. Затем снова откройте GraphiQL.</p>
<p>В области проводника вы увидите <code>allFile</code> и <code>file</code>, доступные как выбранные.</p>
<p>Щелкните раскрывающийся список allFile. Поместите курсор после allFile в область запроса, а затем введите Ctrl + Enter. Это позволит предварительно заполнить запрос на идентификатор каждого файла. Нажмите кнопку &quot;Play&quot;, чтобы выполнить запрос.</p>
<p>На панели проводника поле id было выбрано автоматически. Сделайте выбор для большего количества полей, установив соответствующий флажок поля. Нажмите кнопку &quot;Play&quot;, чтобы снова запустить запрос с новыми полями.</p>
<p>Кроме того, можно добавить поля с помощью сочетания клавиш автозаполнения (Ctrl + пробел).</p>
<p>Попробуйте добавить несколько полей в запрос, нажимайте Ctrl + Enter каждый раз, чтобы повторно выполнить запрос. Вы увидите обновленные результаты запроса:</p>
<h3>Создание страницы с помощью запросов GraphQL</h3>
<p>Создание новых страниц с помощью Gatsby часто начинается в GraphiQL. Сначала вы набрасываете запрос данных, играя в GraphiQL, а затем копируете его в страницу компонента React, чтобы начать построение пользовательского интерфейса.</p>
<p>Создайте новый файл в <code>src/pages/my-files.js</code> с запросом GraphQL <code>allFile</code>, который вы только что создали:</p>
<p>src/pages/my-files.js</p>
<pre><code class="language-jsx">import React from 'react';
import { graphql } from 'gatsby';
import Layout from '../components/layout';

export default ({ data }) =&gt; {
  console.log(data);
  return (
    &lt;Layout&gt;
      &lt;div&gt;Hello world&lt;/div&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query {
    allFile {
      edges {
        node {
          relativePath
          prettySize
          extension
          birthTime(fromNow: true)
        }
      }
    }
  }
`;
</code></pre>
<p>Строка <code>console.log(data)</code> часто полезна при создании нового компонента для вывода данных, которые вы получаете из запроса GraphQL, чтобы вы могли исследовать данные в консоли браузера во время построения пользовательского интерфейса.</p>
<p>Если вы зайдете на новую страницу в <code>/my-files/</code> и откроете консоль браузера, вы увидите что-то вроде:</p>
<p>Форма данных совпадает с формой запроса GraphQL.</p>
<p>Добавьте некоторый код к компоненту, чтобы распечатать данные файла.</p>
<p>src/pages/my-files.js</p>
<pre><code class="language-jsx">import React from 'react';
import { graphql } from 'gatsby';
import Layout from '../components/layout';

export default ({ data }) =&gt; {
  console.log(data);
  return (
    &lt;Layout&gt;
      &lt;div&gt;
        &lt;h1&gt;My Site's Files&lt;/h1&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;relativePath&lt;/th&gt;
              &lt;th&gt;prettySize&lt;/th&gt;
              &lt;th&gt;extension&lt;/th&gt;
              &lt;th&gt;birthTime&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            {data.allFile.edges.map(({ node }, index) =&gt; (
              &lt;tr key={index}&gt;
                &lt;td&gt;{node.relativePath}&lt;/td&gt;
                &lt;td&gt;{node.prettySize}&lt;/td&gt;
                &lt;td&gt;{node.extension}&lt;/td&gt;
                &lt;td&gt;{node.birthTime}&lt;/td&gt;
              &lt;/tr&gt;
            ))}
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query {
    allFile {
      edges {
        node {
          relativePath
          prettySize
          extension
          birthTime(fromNow: true)
        }
      }
    }
  }
`;
</code></pre>
<p>А теперь посетите <code>http://localhost:8000/my-files</code> …</p>
<p>Теперь вы узнали, как плагины source приносят данные в систему данных Gatsby. В следующем уроке вы узнаете, как плагины transformer преобразуют необработанный контент, который приносят Плагины source. Комбинация плагинов source и плагинов transformer может обрабатывать все источники данных и преобразования данных, которые могут потребоваться при создании сайта Gatsby. Узнайте о плагинах transformer в шестой части этого руководства.</p>
<h2>Плагины Transformer</h2>
<p>В предыдущем уроке было показано, как плагины source доставляют данные в систему данных Gatsby. В этом уроке вы узнаете, как плагины transformer преобразуют исходное содержимое, полученное с помощью плагинов source. Комбинация плагинов source и плагинов transformer может обрабатывать все источники данных и преобразовывать данные, которые могут потребоваться при создании сайта на Gatsby.</p>
<p>Часто формат данных, которые вы получаете от source плагинов, не является тем, что вы хотите использовать для создания своего веб-сайта. Source плагин filesystem позволяет запрашивать данные о файлах, но что делать, если вы хотите запросить данные внутри файлов?</p>
<p>Чтобы сделать это возможным, Gatsby поддерживает плагины transformer, которые берут сырой контент из source плагинов и преобразуют его в нечто более полезное.</p>
<p>Возьмем, например, файлы markdown. В markdown удобно писать статьи, но когда вы создаете страницу с ним, вам нужно, чтобы markdown был преобразован в HTML.</p>
<p>Добавьте файл markdown на свой сайт по адресу src/pages/sweet-pandas-eating-sweets.md (это станет вашим первым markdown постом в блоге) и узнайте, как преобразовать его в HTML с помощью плагинов transformer и GraphQL.</p>
<p>src/pages/sweet-pandas-eating-sweets.md</p>
<pre><code class="language-md">---
title: 'Sweet Pandas Eating Sweets'
date: '2017-08-10'
---

Pandas are really sweet.

Here's a video of a panda eating sweets.

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/4n0xNbfJLR8&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
</code></pre>
<p>Как только вы сохраните файл, посмотрите на <code>/my-files/</code> еще раз - новый файл markdown находится в таблице. Это очень сильная функция Gatsby. Как и в предыдущем примере <code>siteMetadata</code>, плагины source могут выполнять оперативную перезагрузку данных. <code>gatsby-source-filesystem</code> всегда ищет новые файлы, которые будут добавлены, и когда они появляются, повторно выполняет ваши запросы.</p>
<p>Добавьте плагин transformer, который может преобразовывать файлы markdown:</p>
<pre><code>npm install --save gatsby-transformer-remark
</code></pre>
<p>Затем добавьте его в <code>gatsby-config.js</code>:</p>
<p>gatsby-config.js</p>
<pre><code class="language-js">module.exports = {
  siteMetadata: {
    title: `Pandas Eating Lots`,
  },
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `src`,
        path: `${__dirname}/src/`,
      },
    },
    `gatsby-transformer-remark`,
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
};
</code></pre>
<p>Перезагрузите сервер разработки, затем обновите (или откройте снова) GraphiQL и посмотрите на автозаполнение.</p>
<p>Снова выберите <code>allMarkdownRemark</code> и запустите его так же, как и для <code>allFile</code>. Вы увидите там файл markdown, который вы недавно добавили. Исследуйте поля, доступные на узле <code>MarkdownRemark</code>.</p>
<h3>Создание списка файлов markdown вашего сайта в src/pages/index.js</h3>
<p>Теперь вам нужно будет создать список ваших файлов markdown на первой странице. Как и во многих блогах, вы хотите, чтобы в конечном итоге список ссылок на первой странице указывал на каждый пост в блоге. С помощью GraphQL вы можете запросить текущий список записей блога markdown, так что вам не нужно будет поддерживать список вручную.</p>
<p>Подобно странице <code>src/pages/my-files.js</code>, заменить <code>src/pages/index.js</code> со следующим, чтобы добавить запрос GraphQL с некоторым начальным HTML и стилем.</p>
<p>src/pages/index.js</p>
<pre><code class="language-jsx">import React from 'react';
import { graphql } from 'gatsby';
import { css } from '@emotion/core';
import { rhythm } from '../utils/typography';
import Layout from '../components/layout';

export default ({ data }) =&gt; {
  console.log(data);
  return (
    &lt;Layout&gt;
      &lt;div&gt;
        &lt;h1
          css={css`
            display: inline-block;
            border-bottom: 1px solid;
          `}
        &gt;
          Amazing Pandas Eating Things
        &lt;/h1&gt;
        &lt;h4&gt;{data.allMarkdownRemark.totalCount} Posts&lt;/h4&gt;
        {data.allMarkdownRemark.edges.map(({ node }) =&gt; (
          &lt;div key={node.id}&gt;
            &lt;h3
              css={css`
                margin-bottom: ${rhythm(1 / 4)};
              `}
            &gt;
              {node.frontmatter.title}{' '}
              &lt;span
                css={css`
                  color: #bbb;
                `}
              &gt;
                — {node.frontmatter.date}
              &lt;/span&gt;
            &lt;/h3&gt;
            &lt;p&gt;{node.excerpt}&lt;/p&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query {
    allMarkdownRemark {
      totalCount
      edges {
        node {
          id
          frontmatter {
            title
            date(formatString: &quot;DD MMMM, YYYY&quot;)
          }
          excerpt
        }
      }
    }
  }
`;
</code></pre>
<p>Теперь первая страница должна выглядеть так:</p>
<p><img src="home.png" alt="home"></p>
<p>Но ваш единственный пост в блоге выглядит немного одиноким. Поэтому давайте добавим еще один в <code>src/pages/pandas-and-bananas.md</code>.</p>
<p>src/pages/pandas-and-bananas.md</p>
<pre><code class="language-md">---
title: 'Pandas and Bananas'
date: '2017-08-21'
---

Do Pandas eat bananas? Check out this short video that shows that yes! pandas do
seem to really enjoy bananas!

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/4SZl1r2O_bY&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
</code></pre>
<p><img src="two-page.png" alt="two-page"></p>
<p>Выглядит великолепно! Вот только ... порядок постов неправильный.</p>
<p>Но это легко исправить. При запросе соединения определенного типа вы можете передать в запрос GraphQL множество аргументов. Вы можете сортировать и фильтровать узлы, задавать количество узлов, которые нужно пропустить, и выбирать предел количества узлов, которые нужно извлечь. С помощью этого мощного набора операторов вы можете выбрать любые данные, которые вы хотите — в нужном вам формате.</p>
<p>В запросе GraphQL страницы индекса измените <code>allMarkdownRemark</code> на <code>allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC })</code>. Примечание: между frontmatter и date есть 3 подчеркивания. Сохраните это, и порядок сортировки должен быть установлен.</p>
<p>Попробуйте открыть GraphiQL и поиграть с различными вариантами сортировки. Вы можете сортировать соединение <code>allFile</code> вместе с другими соединениями.</p>
<p>Для получения дополнительной документации по наши операторы запросов, исследовать наш <a href="https://www.gatsbyjs.org/docs/graphql-reference/">справочник GraphQL</a>.</p>
<p>Это здорово! Вы только что создали красивую index страницу, где вы запрашиваете свои файлы markdown и создаете список заголовков и выдержек из записей в блоге. Но вы не хотите просто видеть выдержки, вам нужны реальные страницы для ваших файлов markdown.</p>
<p>Вы можете продолжать создавать страницы, помещая компоненты React в <code>src/pages</code>. Однако далее вы узнаете, как программно создавать страницы из данных. Gatsby не ограничивается созданием страниц из файлов, как многие статические генераторы сайтов. Gatsby позволяет использовать GraphQL для запроса данных и отображения результатов запроса на страницы — все во время сборки. Это действительно мощная идея. Вы изучите его последствия и способы использования в следующем учебнике, где вы узнаете, как <a href="https://www.gatsbyjs.org/tutorial/part-seven/">программно создавать страницы из данных</a>.</p>
<h2>Программное создание страниц из данных</h2>
<p>В предыдущем руководстве вы создали красивую index страницу, которая запрашивает файлы markdown и создает список заголовков и выдержек из записей блога. Но вам нужны не просто выдержки, а реальные страницы для ваших файлов markdown.</p>
<p>Вы можете продолжать создавать страницы, помещая компоненты React в <code>src/pages</code>. Однако теперь вы узнаете, как программно создавать страницы из данных. Gatsby не ограничивается созданием страниц из файлов, как многие статические генераторы сайтов. Gatsby позволяет использовать GraphQL для запроса данных и отображения результатов запроса на страницах — все во время сборки.</p>
<h3>Создание слагов для страниц</h3>
<p>Чтобы создать новую страницу нужно выполнить два шага:</p>
<ol>
<li>
<p>Создать &quot;путь” или “слаг” для страницы.</p>
</li>
<li>
<p>Создать страницу.</p>
</li>
</ol>
<p>слаг (slug) - понятный человеку фрагмент текста из URL в отличии от, например, ID, который может быть непонятным набором символом.</p>
<p>Примечание: часто источники данных напрямую предоставляют слаг или путь для содержимого - при работе с одной из этих систем (например, CMS), вам не нужно создавать слаги самостоятельно, как вы делаете с файлами markdown.</p>
<p>Для создания страниц markdown вы научитесь использовать два API-интерфейса Gatsby: <code>onCreateNode</code> и <code>createPages</code>. Это две рабочие лошадки API, которые вы увидите на многих сайтах и плагинах.</p>
<p>Мы делаем все возможное, чтобы сделать API Gatsby простыми в реализации. Для реализации API необходимо экспортировать функцию с именем API из <code>gatsby-node.js</code>.</p>
<p>В корне вашего сайта создайте файл с именем <code>gatsby-node.js</code>. Затем в него добавьте следующее.</p>
<pre><code class="language-js">exports.onCreateNode = ({ node }) =&gt; {
  console.log(node.internal.type);
};
</code></pre>
<p>Эта функция <code>onCreateNode</code> будет вызываться Gatsby всякий раз, когда создается (или обновляется) новый узел.</p>
<p>Остановите и перезапустите сервер разработки. Как только вы это сделаете, вы увидите, что довольно много вновь созданных узлов войдут в консоль терминала.</p>
<p>В следующем разделе вы будете использовать этот API, чтобы добавлять слаги для ваших Markdown страниц <code>MarkdownRemark</code> узлов.</p>
<p>gatsby-node.js</p>
<pre><code class="language-js">exports.onCreateNode = ({ node }) =&gt; {
  if (node.internal.type === `MarkdownRemark`) {
    console.log(node.internal.type);
  }
};
</code></pre>
<p>Вы хотите использовать каждое имя файла markdown для создания слага страницы. Так <code>pandas-and-bananas.md</code> станет <code>/pandas-and-bananas/</code>. Но как получить имя файла из узла <code>MarkdownRemark</code>? Чтобы получить его, вам нужно пересечь “узловой граф &quot; к его родительскому узлу <code>File</code>, так как узлы <code>File</code> содержат необходимые вам данные о файлах на диске. Для этого снова измените свою функцию:</p>
<p>gatsby-node.js</p>
<pre><code class="language-js">exports.onCreateNode = ({ node, getNode }) =&gt; {
  if (node.internal.type === `MarkdownRemark`) {
    const fileNode = getNode(node.parent);
    console.log(`\n`, fileNode.relativePath);
  }
};
</code></pre>
<p>После перезагрузки сервера разработки вы должны увидеть относительные пути для двух файлов markdown, напечатанных на экране терминала.</p>
<pre><code> pages/sweet-pandas-eating-sweets.md

 pages/pandas-and-bananas.md
</code></pre>
<p>Теперь вам придется создавать слаги. Поскольку логика создания слагов из имен файлов может быть сложной, плагин <code>gatsby-source-filesystem</code> поставляется с функцией для создания слагов. Давайте воспользуемся этим.</p>
<p>gatsby-node.js</p>
<pre><code class="language-js">const { createFilePath } = require(`gatsby-source-filesystem`);

exports.onCreateNode = ({ node, getNode }) =&gt; {
  if (node.internal.type === `MarkdownRemark`) {
    console.log(createFilePath({ node, getNode, basePath: `pages` }));
  }
};
</code></pre>
<p>Функция обрабатывает поиск родительского узла <code>File</code> вместе с созданием слага. Запустите сервер разработки еще раз, и вы увидите, что в терминал вошли два слага, по одному для каждого файла markdown.</p>
<p>Теперь вы можете добавлять новые слаги непосредственно на узлы <code>MarkdownRemark</code>. Это очень важно, так как любые данные, которые вы добавляете в узлы, доступны для последующего запроса с помощью GraphQL. Так что, когда придет время создавать страницы, будет легко получить слаг.</p>
<p>Для этого вы будете использовать функцию, переданную в вашу реализацию API под названием <code>createNodeField</code>. Эта функция позволяет создавать дополнительные поля в узлах, созданных другими плагинами. Только первоначальный создатель узла может непосредственно модифицировать узел - все остальные плагины (включая ваш <code>gatsby-node.js</code>) должны использовать эту функцию для создания дополнительных полей.</p>
<p>gatsby-node.js</p>
<pre><code class="language-js">const { createFilePath } = require(`gatsby-source-filesystem`);
exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions;
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` });
    createNodeField({
      node,
      name: `slug`,
      value: slug,
    });
  }
};
</code></pre>
<p>Перезагрузите сервер разработки и откройте или обновите GraphiQL. Затем запустите этот запрос GraphQL, чтобы увидеть ваши новые слаги.</p>
<pre><code class="language-graphql">{
  allMarkdownRemark {
    edges {
      node {
        fields {
          slug
        }
      }
    }
  }
}
</code></pre>
<p>Теперь, когда слаги созданы, вы можете создавать страницы.</p>
<h3>Создание страниц</h3>
<p>В том же файле <code>gatsby-node.js</code>, добавьте следующее.</p>
<pre><code class="language-js">const { createFilePath } = require(`gatsby-source-filesystem`);

exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions;
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` });
    createNodeField({
      node,
      name: `slug`,
      value: slug,
    });
  }
};

exports.createPages = async ({ graphql, actions }) =&gt; {
  // **Note:** The graphql function call returns a Promise
  // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise for more info
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `);
  console.log(JSON.stringify(result, null, 4));
};
</code></pre>
<p>Вы добавили реализацию API <code>createPages</code>, который вызывает Gatsby, чтобы плагины могли добавлять страницы.</p>
<p>Как уже упоминалось во введении к этой части руководства, шагами по программному созданию страниц являются:</p>
<ol>
<li>
<p>Запрос данных с помощью GraphQL</p>
</li>
<li>
<p>Отображение результатов запроса на страницах</p>
</li>
</ol>
<p>Приведенный выше код является первым шагом для создания страниц из вашего markdown, поскольку вы используете предоставленную функцию <code>graphql</code> для запроса созданных вами слагов markdown. Затем вы выводите результат запроса, который должен выглядеть подобным образом:</p>
<p><img src="query-markdown-slugs.png" alt="query-markdown-slugs"></p>
<p>Для создания страниц вам понадобится еще одна вещь помимо слага: компонент шаблона страницы. Как и все в Gatsby, программные страницы питаются компонентами React. При создании страницы необходимо указать, какой компонент использовать.</p>
<p>Создайте каталог в <code>src/templates</code>, а затем добавьте следующее в файл с именем <code>src/templates/blog-post.js</code>.</p>
<pre><code class="language-jsx">import React from 'react';
import Layout from '../components/layout';

export default () =&gt; {
  return (
    &lt;Layout&gt;
      &lt;div&gt;Hello blog post&lt;/div&gt;
    &lt;/Layout&gt;
  );
};
</code></pre>
<p>Затем измените gatsby-node.js</p>
<pre><code class="language-js">const path = require(`path`);
const { createFilePath } = require(`gatsby-source-filesystem`);

exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions;
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` });
    createNodeField({
      node,
      name: `slug`,
      value: slug,
    });
  }
};

exports.createPages = async ({ graphql, actions }) =&gt; {
  const { createPage } = actions;
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `);

  result.data.allMarkdownRemark.edges.forEach(({ node }) =&gt; {
    createPage({
      path: node.fields.slug,
      component: path.resolve(`./src/templates/blog-post.js`),
      context: {
        // Data passed to context is available
        // in page queries as GraphQL variables.
        slug: node.fields.slug,
      },
    });
  });
};
</code></pre>
<p>Перезагрузите сервер разработки, и ваши страницы будут созданы! Простой способ найти новые страницы, которые вы создаете во время разработки, - это перейти на случайный путь, где Gatsby с удовольствием покажет вам список страниц на сайте. Если вы идете в http://localhost:8000/sdf, вы увидите новые страницы, которые вы создали.</p>
<p>Это немного скучно и не то, что вы хотите. Теперь вы можете получить данные из вашего поста markdown. Измените <code>src/templates/blog-post.js</code> следующим образом:</p>
<pre><code class="language-jsx">import React from 'react';
import { graphql } from 'gatsby';
import Layout from '../components/layout';

export default ({ data }) =&gt; {
  const post = data.markdownRemark;
  return (
    &lt;Layout&gt;
      &lt;div&gt;
        &lt;h1&gt;{post.frontmatter.title}&lt;/h1&gt;
        &lt;div dangerouslySetInnerHTML={{ __html: post.html }} /&gt;
      &lt;/div&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query ($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug } }) {
      html
      frontmatter {
        title
      }
    }
  }
`;
</code></pre>
<p>Последний шаг - это ссылка на ваши новые страницы с индексной страницы.</p>
<p>Вернитесь к <code>src/pages/index.js</code>, запросите ваши слаги markdown и создайте ссылки.</p>
<pre><code class="language-jsx">import React from 'react';
import { css } from '@emotion/core';
import { Link, graphql } from 'gatsby';
import { rhythm } from '../utils/typography';
import Layout from '../components/layout';

export default ({ data }) =&gt; {
  return (
    &lt;Layout&gt;
      &lt;div&gt;
        &lt;h1
          css={css`
            display: inline-block;
            border-bottom: 1px solid;
          `}
        &gt;
          Amazing Pandas Eating Things
        &lt;/h1&gt;
        &lt;h4&gt;{data.allMarkdownRemark.totalCount} Posts&lt;/h4&gt;
        {data.allMarkdownRemark.edges.map(({ node }) =&gt; (
          &lt;div key={node.id}&gt;
            &lt;Link
              to={node.fields.slug}
              css={css`
                text-decoration: none;
                color: inherit;
              `}
            &gt;
              &lt;h3
                css={css`
                  margin-bottom: ${rhythm(1 / 4)};
                `}
              &gt;
                {node.frontmatter.title}{' '}
                &lt;span
                  css={css`
                    color: #555;
                  `}
                &gt;
                  — {node.frontmatter.date}
                &lt;/span&gt;
              &lt;/h3&gt;
              &lt;p&gt;{node.excerpt}&lt;/p&gt;
            &lt;/Link&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query {
    allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC }) {
      totalCount
      edges {
        node {
          id
          frontmatter {
            title
            date(formatString: &quot;DD MMMM, YYYY&quot;)
          }
          fields {
            slug
          }
          excerpt
        }
      }
    }
  }
`;
</code></pre>
<p>В этой части урока вы изучили основы построения с помощью слоя данных Gatsby. Вы узнали, как создавать и преобразовывать данные с помощью плагинов, как использовать GraphQL для отображения данных на страницы, а затем как создавать компоненты шаблонов страниц, в которых запрашиваются данные для каждой страницы.</p>
<ul>
<li>
<p>Вы можете взглянуть на некоторые <a href="https://github.com/gatsbyjs/gatsby/tree/master/examples#gatsby-example-websites">примеры сайтов</a></p>
</li>
<li>
<p>Узнать больше <a href="https://www.gatsbyjs.org/docs/plugins/">о плагинах</a></p>
</li>
<li>
<p>Посмотрите, что <a href="https://www.gatsbyjs.org/showcase/">другие люди строят создают с помощью Гэтсби</a></p>
</li>
<li>
<p>Ознакомьтесь с документацией по <a href="https://www.gatsbyjs.org/docs/api-specification/">Gatsby’s APIs</a>, <a href="https://www.gatsbyjs.org/docs/node-interface/">nodes</a>, или <a href="https://www.gatsbyjs.org/docs/graphql-reference/">GraphQL</a></p>
</li>
</ul>

      </div>
    </div>
    <footer class="footer"> 
      <div class="footer__content content">
        <div class="footer__contacts" id="contacts"> <a class="footer__email-link" href="mailto:injashkin@gmail.com" title="Написать письмо">
            <svg class="icon icon__undefined" role="img" width="1em" height="1em">
              <use href="/sprite.svg#undefined"></use>
            </svg>
            <div class="footer__email">injashkin@gmail.com</div></a></div>
        <div class="footer__developer"> <a href="http://jinv.ru" target="_blank">Разработка сайта jinv.ru</a></div>
        <div class="footer__copyright-wrap">
          <div class="footer__copyright">jinv.ru © 2019 - 2022</div>
        </div>
      </div>
    </footer><!-- Yandex.Metrika counter -->
<script type="text/javascript">
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function () {
      try {
        w.yaCounter60672532 = new Ya.Metrika({
          id: 60672532,
          clickmap: true,
          trackLinks: true,
          accurateTrackBounce: true,
        });
      } catch (e) {}
    });

    var n = d.getElementsByTagName('script')[0],
      x = 'https://mc.yandex.ru/metrika/watch.js',
      s = d.createElement('script'),
      f = function () {
        n.parentNode.insertBefore(s, n);
      };
    for (var i = 0; i < document.scripts.length; i++) {
      if (document.scripts[i].src === x) {
        return;
      }
    }
    s.type = 'text/javascript';
    s.async = true;
    s.src = x;

    if (w.opera == '[object Opera]') {
      d.addEventListener('DOMContentLoaded', f, false);
    } else {
      f();
    }
  })(document, window, 'yandex_metrika_callbacks');
</script>
<noscript
  ><div>
    <img
      src="https://mc.yandex.ru/watch/60672532"
      style="position: absolute; left: -9999px"
      alt=""
    /></div
></noscript>
<!-- /Yandex.Metrika counter -->

  </body>
</html>