<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/index.1gf8aesg9.css">
    <script defer src="/index.1gf8aesg9.js"></script>
    <meta name="description" content="Установка и настройка сборки из NPM модулей, которая позволит создать статический сайт используя шаблонизатор Pug, препроцессор Sass, язык JavaScript и разметку Markdown">
    <title>Настройка среды разработки из NPM модулей и создание статического сайта | jinv.ru</title>
    <link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="images/icons/icon57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/icons/icon60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/icons/icon72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/icons/icon76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/icons/icon114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/icons/icon120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/icons/icon144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/icons/icon152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/icons/icon180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="images/icons/icon192.png">
    <link rel="icon" href="images/icons/icon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="images/icons/icon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="images/icons/icon96.png" type="image/png" sizes="96x96">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/icons/icon144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <header class="header">
      <div class="header__content content">           
        <div class="header__logo">
          <div class="logo">        <a href="/" title="jinv.ru"> 
              <svg class="icon icon__logo" role="img" width="14em" height="5em">
                <use href="/sprite.svg#logo"></use>
              </svg></a></div>
          <div class="logo_mobile"><a href="/" title="jinv.ru"><img src="/images/icon-72x72.png" alt="Логотип сайта jinv.ru"/></a></div>
        </div>
        <nav class="menu" aria-label="Главное меню">   
          <div class="content"> 
            <input id="menu__toggle" type="checkbox"/>
            <label class="menu__btn" for="menu__toggle"><span>   </span></label>
            <ul class="menu__box">
              <li><a class="menu__item" href="/">Главная</a></li>
              <li><a class="menu__item" href="/toc.html">Статьи</a></li>
              <li><a class="menu__item" href="/author.html">Об авторе</a></li>
            </ul>
          </div>
        </nav>
        <div class="theme">
          <select id="theme" name="theme">        
            <option value="auto">Авто      </option>
            <option value="light">Светлая      </option>
            <option value="dark">Темная    </option>
          </select>
        </div>
        <div class="header__contacts">
          <div class="send-mes">
            <div class="soc"><a class="mes-em" href="injashkin@gmail.com" title="Email" target="_blank" rel="nofollow">
                <svg class="icon icon__email" role="img" width="1em" height="1em">
                  <use href="/sprite.svg#email"></use>
                </svg></a><a class="mes-tg" href="https://t.me/jashkin" title="Telegram" target="_blank" rel="nofollow">
                <svg class="icon icon__telegram" role="img" width="1em" height="1em">
                  <use href="/sprite.svg#telegram"></use>
                </svg></a><a class="mes-wa" href="https://api.whatsapp.com/send?phone=79183549497" title="WhatsApp" target="_blank" rel="nofollow">
                <svg class="icon icon__whatsapp" role="img" width="1em" height="1em">
                  <use href="/sprite.svg#whatsapp"></use>
                </svg></a>
            </div>
          </div>
          <div class="contacts">         
            <p> <a href="https://github.com/injashkin/injashkin.github.io">Github</a></p>
          </div>
        </div>
      </div>
    </header>
    <div class="content">
      <div class="article">
        <h1>Настройка среды разработки из NPM модулей и создание статического сайта</h1>
        <div class="creationDate">Создано: 09-08-2022</div><h2>О чем статья</h2>
<p>В статье показано, как настроить собственную сборку из модулей NPM, которая является полным аналогом сборки <a href="https://github.com/injashkin/npm-for-frontend">npm-for-frontend</a>. Эта сборка позволит создавать статические страницы сайта, а именно:</p>
<ul>
<li>Создавать разметку с помощью шаблонизатора Pug.</li>
<li>Стилизовать страницы с помощью препроцессора Sass.</li>
<li>Наполнять содержимое страниц сайта с помощью разметки Markdown.</li>
<li>Добавлять картинки, значки, шрифты.</li>
<li>Добавлять интерактив на сайт используя самые последние достижения языка JavaScript и при этом не переживать, что какая-то новая функция не будет распознана старым браузером.</li>
</ul>
<p>Сама сборка будет выполнять следующие функции:</p>
<ul>
<li>Автоматически преобразовывать Pug разметку и разметку Markdown в понятный для браузеров HTML</li>
<li>Автоматически преобразовывать Sass стили и объединять их в один файл <code>index.css</code>.</li>
<li>Все скрипты будут транспилированы и упакованы в один файл <code>index.js</code>.</li>
<li>Автоматически оптимизировать картинки, значки, шрифты для увеличения быстродействия готового сайта.</li>
</ul>
<h2>Быстрый запуск проекта</h2>
<p>Чтобы выполнять дальнейшие действия у нас на компьютере должен быть установлен <a href="https://nodejs.org/">Node.js</a> и NPM.</p>
<p>Откроем терминал и создадим каталог <code>my-project</code> нашего будущего проекта, и сразу перейдем в него:</p>
<pre><code>mkdir my-project
cd my-project
</code></pre>
<p>Теперь, если нам нужна система контроля версий Git, то выполним два простых шага, сначала, инициализируем Git:</p>
<pre><code>git init
</code></pre>
<p>Затем создадим файл <code>.gitignore</code>:</p>
<pre><code>touch .gitignore
</code></pre>
<p>В этом файле будем указывать игнорируемые файлы и каталоги, которые не должны попадать в коммиты. Если файл <code>.gitignore</code> не виден в каталоге, то нужно нажать сочетание клавиш <code>Ctrl+H</code>. Запишем в файле <code>.gitignore</code> следующее:</p>
<pre><code>node_modules
</code></pre>
<p>С настройками Git в этом проекте покончено. Теперь не забываем, хотя бы иногда, делать коммиты.</p>
<p>Инициализируем npm. Для этого введем в терминале команду:</p>
<pre><code>npm init -y
</code></pre>
<p>Будет создан файл <code>package.json</code> с настройками по умолчанию (опция -y). Наиболее полную информацию о файле package.json можно прочитать в <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">документации по npm</a>.</p>
<h2>Подключение и настройка шаблонизатора Pug</h2>
<p>В настоящее время мало кто верстает на чистом HTML. Придуманы более удобные для написания языки и инструменты, которые эти языки преобразуют в HTML. Одним из таких инструментов является <a href="https://pugjs.org/">шаблонизатор Pug</a>, который имеет свой, более удобный синтаксис для написания разметки. После компиляции синтаксис Pug превращается в разметку HTML.</p>
<p>Установим pug. Для этого введем в терминале команду:</p>
<pre><code>npm i -D pug-cli
</code></pre>
<p>Вместо опции <code>i</code> можно написать <code>install</code>. Опция <code>-D</code> указывает, что устанавливаемый пакет нужен только для разработки и не будет использоваться в производственной сборке. Поэтому, устанавливаемый пакет будет прописан в секции <code>&quot;devDependencies&quot;: {...}</code> файла <code>package.json</code>.</p>
<p>В результате, в корневом каталоге проекта будет создан каталог <code>node_modules</code> и файл <code>package-lock.json</code>. Каталог <code>node_modules</code> содержит все установленные зависимости проекта. Обычно этот каталог не рекомендуется включать в репозитории, что мы и сделали, проигнорировав его в файле <code>.gitignore</code>. Файл <code>package-lock.json</code> хранит записи о точных версиях установленных зависимостей.</p>
<p>Создадим в корне проекта каталог <code>src</code>, в котором создадим каталог <code>pages</code>, в нем создадим каталог <code>home</code>, а уже в нем создадим файл <code>index.pug</code> со следующим содержимым:</p>
<p><strong>src/pages/home/index.pug</strong></p>
<pre><code class="language-pug">h1.name= 'Код написан с помощью разметки Pug!'
</code></pre>
<p>Сохраним файл.</p>
<p>Создание каталогов здесь и далее может быть произвольным, но исходя из опыта лучше сразу придерживаться определенной структуры, чтобы потом мучительно не переделывать проект.</p>
<p>Настроим Pug для работы. Для этого добавим в секцию <code>&quot;scripts&quot;</code> файла <code>package.json</code> скрипт с именем <code>&quot;pug&quot;</code> (знак плюс <code>+</code> дальше по тексту будет лишь указывать на добавленные строки кода):</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;my-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
+   &quot;pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;pug-cli&quot;: &quot;^1.0.0-alpha6&quot;
  }
}
</code></pre>
<ul>
<li>Опция <code>--pretty</code> (или <code>-P</code>) отключает минификацию, что дает на выходе красиво оформленную разметку HTML. По умолчанию, pug переводит код в минимизированный HTML, из которого вырезаны пробелы между тегами, табуляция и перевод строк.</li>
<li>Ключ <code>-w</code> (или <code>--watch</code>) заставляет Pug следить за изменениями в файлах с расширениями <code>.pug</code> и как только мы сохраняем измененный файл, то Pug сразу перекомпилирует исходники.</li>
<li>Путь <code>src/pages/home/index.pug</code> указывает на входной файл. Этот файл после компиляции будет на выходе с расширением <code>.html</code>. Если мы укажем каталог, то все файлы с расширением <code>.pug</code> этого каталога появятся на выходе с расширением <code>.html</code>, что не всегда бывает нужно.</li>
<li>Ключ <code>-o</code> (или <code>--out</code>) указывает, что откомпилированные файлы будут выводится в другой каталог. Этот каталог нужно указать сразу после ключа, в нашем случае это каталог <code>dist</code>. Если такого каталога не существует, он будет создан.</li>
<li><code>dist</code> - это каталог, в который будут компилироваться файлы. Можно указать имя конкретного файла, который должен получится на выходе, например, <code>dist/index.html</code>. Тогда ключ <code>-o</code> следует опустить, иначе имя файла будет воспринято как имя каталога. К тому же, все каталоги, указанные в пути должны существовать, так как без ключа <code>-o</code> каталоги не создаются.</li>
</ul>
<p>Более подробно об опциях командной строки можно узнать в <a href="https://github.com/pugjs/pug-cli">репозитории pug-cli</a></p>
<p>После установки и конфигурации шаблонизатора Pug проверим его в работе. Из корневого каталога проекта запустим в терминале команду:</p>
<pre><code>npm run pug
</code></pre>
<p>Будет создан каталог <code>dist</code>, а в нем файл <code>index.html</code>. Если мы откроем этот файл в браузере, то увидим следующее:</p>
<pre><code>Код написан с помощью разметки Pug!
</code></pre>
<p>Если мы откроем файл <code>dist/index.html</code> в редакторе кода то увидим откомпилированную HTML разметку:</p>
<pre><code class="language-html">&lt;h1 class=&quot;name&quot;&gt;Код написан с помощью разметки Pug&lt;/h1&gt;
</code></pre>
<p>Чтобы данный файл был полноценной HTML страницей и без ошибок проходил <a href="https://validator.w3.org/#validate_by_upload">валидатор</a> в файл нужно добавить теги <code>&lt;!DOCTYPE html&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code> и некоторые теги <code>&lt;meta&gt;</code>. Данные теги должны присутствовать на каждой HTML странице.</p>
<p>Чтобы не повторять во всех шаблонах Pug одинаковый код, создадим общий шаблон, который будет применятся ко всем страницам нашего сайта. Для этого в каталоге <code>src</code> создадим каталог <code>layouts</code>, внутри которого создадим каталог <code>base</code>, а в нем файл <code>index.pug</code> со следующим содержимым:</p>
<p><strong>src/layouts/base/index.pug</strong></p>
<pre><code class="language-pug">-
  let data = {
    default_description: &quot;Показан пример общего шаблона Pug для всех страниц&quot;,
    default_title: &quot;Общий шаблон Pug&quot;
  }

- const {default_title, default_description} = data

doctype html
html(lang='ru')
  head
    meta(charset='utf-8')
    meta(name='viewport' content='width=device-width, initial-scale=1.0')

    meta(name= 'description' content= description ? description : default_description)
    title= title ? title : default_title

  body
    block main
</code></pre>
<p>Содержимое файла <code>src/pages/home/index.pug</code> изменим на следующее:</p>
<pre><code class="language-pug">extends ../../layouts/base/index

block main
  h1.name= 'Код написан с помощью разметки Pug!'
</code></pre>
<p>Теперь, если мы откроем файл <code>dist/index.html</code> в редакторе кода, мы увидим следующую разметку:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ru&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta
      name=&quot;description&quot;
      content=&quot;Показан пример общего шаблона Pug для всех страниц&quot;
    /&gt;
    &lt;title&gt;Общий шаблон Pug&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1 class=&quot;name&quot;&gt;Код написан с помощью разметки Pug!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Если мы этого не увидим, значит мы либо закрыли окно терминала с выполняемым компилятором Pug, либо что-то сделали неправильно.</p>
<p>Проверка данного файла в <a href="https://validator.w3.org/#validate_by_upload">валидаторе</a> не выявит никаких ошибок.</p>
<p>Далее, мы создадим простую кнопку и добавим ее на страницу сайта. Реализуем кнопку с помощью миксина. Для этого создадим в каталоге <code>src</code> каталог <code>components</code>, в котором создадим каталог <code>button</code>, а в нем файл <code>button.pug</code> со следующим содержимым:</p>
<pre><code class="language-pug">mixin button
  button.button= 'Кнопка добавлена с помощью миксина'
</code></pre>
<p>Не забываем сохранить файл.</p>
<p>В файл <code>src/pages/home/index.pug</code> подключим файл <code>button.pug</code> с помощью <code>include</code> и вызовем в нужном месте как миксин <code>+button()</code>:</p>
<pre><code class="language-pug">extends ../../layouts/base/index
include ../../components/button/button.pug

block main
  h1.name= 'Код написан с помощью разметки Pug!'
  +button
</code></pre>
<p>После сохранения файла перезагрузим страницу браузера и мы увидим заголовок, а под ним кнопку:</p>
<p><img src="added-button.png" alt="Добавлена кнопка с помощью миксина"></p>
<h2>Настройка локального сервера BrowserSync</h2>
<p>После очередного изменения кода, чтобы увидеть откомпилированный результат, нужно каждый раз вручную обновлять страницу браузера. Это очень быстро надоедает. Для того, чтобы после сохранения редактируемого файла браузер автоматически обновлял страницу можно использовать локальный сервер, такой как <a href="https://browsersync.io/docs/command-line">BrowserSync</a> или <a href="https://github.com/ctrlaltdev/pug-server">Pug Server</a>. Мы будем использовать сервер BrowserSync, установим его. Для этого откроем новое окно терминала, так как в первом окне у нас запущен Pug, который работает в режиме наблюдения за файлами, и, сделав рабочим корневой каталог проекта, введем следующую команду:</p>
<pre><code>npm i -D browser-sync
</code></pre>
<p>Добавим в файл <code>package.json</code> настройку, отмеченную знаком <code>+</code>:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
+   &quot;serve&quot;: &quot;browser-sync dist -w&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>Данный скрипт будет запускать сервер, а сервер будет наблюдать за всеми файлами в каталоге <code>dist</code>. Скрипт работает в browser-sync версии 2.23.0 и выше. Аналог данного скрипта, который будет работать в browser-sync любой версии приведен ниже:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    ...
    &quot;serve&quot;: &quot;browser-sync start -s dist -f dist&quot;
  },
</code></pre>
<p>Теперь в окне терминала выполним команду:</p>
<pre><code>npm run serve
</code></pre>
<p>В результате, откроется браузер, в котором мы увидим нашу страницу.</p>
<p>Теперь, каждый раз, когда в каталоге <code>dist</code> происходят какие-либо изменения сервер будет автоматически обновлять браузер.</p>
<h2>Последовательный и параллельный запуск скриптов с помощью npm-run-all</h2>
<p>Мы видим один неприятный момент. Для того, чтобы запустить шаблонизатор Pug в режиме наблюдения мы должны открыть окно терминала и выполнить команду <code>npm run pug</code>, затем, чтобы запустить сервер, нужно открыть другое окно терминала и выполнить <code>npm run serve</code>. И так нужно поступать каждый раз, когда начинаете процесс разработки. В дальнейшем, нам понадобится запускать в режиме наблюдения препроцессор Sass, постпроцессор Postcss, компилятор Babel и др. Если на каждую такую задачу открывать окно терминала и запускать команду типа <code>npm run *</code>, то это будет рутина.</p>
<p>Чтобы упростить процесс одновременного запуска нескольких npm-скриптов можно воспользоваться пакетами <a href="https://www.npmjs.com/package/concurrently">concurrently</a> или <a href="https://github.com/mysticatea/npm-run-all">npm-run-all</a>. Здесь мы воспользуемся инструментом <code>npm-run-all</code>. Сначала установим его. Для этого откроем третье окно терминала и сделав рабочим корневой каталог проекта выполним следующую команду:</p>
<pre><code>npm i -D npm-run-all
</code></pre>
<p>Затем отредактируем файл <code>package.json</code>:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
+   &quot;watch:pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
+   &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
+   &quot;dev&quot;: &quot;npm-run-all -p watch:*&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>Сохраним файл <code>package.json</code>.</p>
<p>Мы добавили скрипт <code>&quot;dev&quot;: &quot;npm-run-all -p watch:*&quot;</code>, в котором опция <code>-p</code> (или <code>--parallel</code>) указывает на параллельное выполнение скриптов, следующих за этой опцией. У нас за этой опцией следует шаблон <code>watch:*</code>. Это значит, что параллельно будут выполнятся все скрипты, у которых в названии есть <code>watch:</code>. Поэтому, мы изменили имена скриптов: имя <code>&quot;pug&quot;</code> заменили на <code>&quot;watch:pug&quot;</code>; имя <code>&quot;serve&quot;</code> заменили на <code>&quot;watch:serve&quot;</code>.</p>
<p>Более подробно об опциях командной строки можно узнать из <a href="https://github.com/mysticatea/npm-run-all/blob/master/docs/npm-run-all.md">документации инструмента npm-run-all</a></p>
<p>Теперь, закроем все окна терминала кроме одного последнего и запустим следующую команду:</p>
<pre><code>npm run dev
</code></pre>
<p>Мы увидим, что откроется браузер со страницей нашего сайта. И для этого нам понадобилось одно окно терминала и всего одна команда.</p>
<p>Возможно, кто-то скажет, что в NPM есть операторы <code>&amp;</code> и <code>&amp;&amp;</code>, с помощью которых можно выполнить все тоже самое. Но оператор <code>&amp;</code> не работает в Windows <code>cmd.exe</code>, а <code>npm-run-all -p</code> там отлично работает.</p>
<h2>Установка и настройка rimraf для очистки каталогов</h2>
<p>Перед началом компиляции полезно будет очищать каталог <code>dist</code> от предыдущих файлов. Для этого будем использовать пакет <code>rimraf</code>, который является аналогом UNIX команды <code>rm -rf</code>, но работает в любой системе, которая поддерживает NPM. Установим этот пакет:</p>
<pre><code>npm i -D rimraf
</code></pre>
<p>В файл <code>package.json</code> внесем правки:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
+   &quot;clean&quot;: &quot;rimraf dist&quot;,
+   &quot;pug&quot;: &quot;pug --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;watch:pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
+   &quot;dev&quot;: &quot;npm-run-all clean pug -p watch:*&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>Мы создали скрипт <code>&quot;clean&quot;</code> для запуска rimraf и указали в скрипте <code>&quot;dev&quot;</code>, чтобы скрипт <code>&quot;clean&quot;</code> запускался самым первым. Так как скрипт <code>&quot;clean&quot;</code> удаляет каталог <code>dist</code>, то при параллельном запуске <code>pug</code> и <code>browser-sync</code> последний выдает ошибку. Поэтому, мы добавили дополнительный скрипт <code>&quot;pug&quot;</code> без режима наблюдения.</p>
<p>Закроем все окна терминала и откроем одно новое и сделав корневой каталог проекта рабочим выполним в терминале привычную нам команду:</p>
<pre><code>npm run dev
</code></pre>
<p><code>npm-run-all</code> выполнил сначала скрипт <code>&quot;clean&quot;</code>, потом скрипт <code>&quot;pug'</code>, а после параллельно запустил два скрипта: <code>&quot;watch:pug&quot;</code> и <code>&quot;watch:serve&quot;</code>.</p>
<h2>Установка и настройка препроцессора node-sass и постпроцессора PostCSS с плагинами PostCSS Preset Env и cssnano</h2>
<p>Для написания стилей мы будем использовать препроцессор <a href="https://github.com/sass/node-sass#command-line-interface">Sass</a>. Он позволяет нам использовать переменные, вложенности, миксины, наследование, математические операторы и др.</p>
<p>При написании стилей мы не хотим задумываться о префиксах, которые необходимы для корректной работы некоторых браузеров, а также, мы уже сегодня хотим использовать современный CSS не думая о его поддержке всеми браузерами. В этом нам поможет PostCSS с плагином <a href="https://github.com/csstools/postcss-plugins/tree/main/plugin-packs/postcss-preset-env">PostCSS Preset Env</a>. Этот плагин преобразует современный CSS в тот CSS, который понятен большинству браузеров, а также расставляет префиксы при необходимости.</p>
<p>Для производственной сборки важно минимизировать и сжать CSS, для более быстрой загрузки стилей. Поэтому, мы будем использовать плагин <a href="http://cssnano.co/">cssnano</a>, который сохраняя семантику удаляет ненужные пробелы и повторяющиеся правила, сжимает идентификаторы, убирает комментарии, удаляет устаревшие вендорные префиксы и выполняет много других оптимизаций.</p>
<p>Нам еще понадобится <a href="https://github.com/postcss/postcss-cli">postcss-cli</a>, чтобы запускать PostCSS из командной строки. Для начала установим все необходимые пакеты:</p>
<pre><code>npm i -D node-sass postcss postcss-cli postcss-preset-env cssnano
</code></pre>
<p>Теперь приступим к написанию стилей. Создадим файл <code>./src/index.scss</code> и скопируем в него следующее:</p>
<pre><code class="language-scss">$font-size: 1rem;
$font-color: lch(28 99 35);

html {
  font-size: $font-size;
  color: $font-color;
}

.example {
  user-select: none;
}
</code></pre>
<p>Добавим в файл <code>package.json</code> следующий код:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
+   &quot;clean&quot;: &quot;rimraf dist tmp&quot;,
    &quot;pug&quot;: &quot;pug --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;watch:pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
+   &quot;sass&quot;: &quot;node-sass src/index.scss -o tmp&quot;,
+   &quot;watch:sass&quot;: &quot;node-sass -w src/index.scss -o tmp&quot;,
+   &quot;watch:post&quot;: &quot;postcss -w tmp -d dist -u postcss-preset-env&quot;,
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
+   &quot;dev&quot;: &quot;npm-run-all clean pug sass -p watch:*&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>Разберемся, что делают эти скрипты.</p>
<ul>
<li><code>&quot;clean&quot;: &quot;rimraf dist tmp&quot;</code></li>
</ul>
<p><code>rimraf</code> удаляет каталоги <code>dist</code> и <code>tmp</code>.</p>
<ul>
<li><code>&quot;sass&quot;: &quot;node-sass src/index.scss -o tmp&quot;</code></li>
</ul>
<p><code>node-sass</code> создает каталог <code>tmp</code> и однократно выполняет следующее - файл <code>src/index.scss</code> и подключенные к нему другие файлы <code>.scss</code> компилирует и помещает файл <code>tmp/index.css</code>.
Опция <code>-o</code> указывает, что скомпилированные файлы выводятся в каталог, который указывается после этой опции. Здесь этим каталогом является временный каталог <code>tmp</code>. Временный он потому, что после компиляции препроцессором файлы должны будут обработаны постпроцессором.</p>
<ul>
<li><code>&quot;watch:sass&quot;: &quot;node-sass -w src/index.scss -o tmp&quot;</code></li>
</ul>
<p><code>node-sass</code> следит за файлом <code>src/index.scss</code> и каждый раз компилирует его при изменении содержимого, а полученный файл сохраняет в каталоге <code>tmp</code> с именем <code>index.css</code>.
Скрипт <code>&quot;watch:sass&quot;</code> не сильно отличается от скрипта <code>&quot;sass&quot;</code>. Разница в опции <code>-w</code>, которая запускает <code>node-sass</code> в режиме наблюдения. Если вызывать скрипт с опцией <code>-w</code>, то <code>node-sass</code> не сможет создать отсутствующий каталог. Поэтому сначала вызываем скрипт без опции <code>-w</code>, а потом с этой опцией.</p>
<ul>
<li><code>&quot;watch:post&quot;: &quot;postcss -w tmp -d dist -u postcss-preset-env&quot;</code></li>
</ul>
<p><code>postcss</code> следит за каталогом <code>tmp</code> и если содержимое файлов в нем меняется, то файлы прогоняются через указанные плагины и помещаются в каталог <code>dist</code> с расширением <code>.css</code>
Опция <code>-u</code> указывает, какие плагины должен использовать <code>postcss</code> - здесь <code>postcss-preset-env</code></p>
<ul>
<li><code>&quot;dev&quot;: &quot;npm-run-all clean sass -p watch:*&quot;</code></li>
</ul>
<p><code>npm-run-all</code> запускает последовательно скрипт <code>clean</code> потом <code>sass</code>, затем запускает параллельно (<code>-p</code>) скрипты, у которых имя начинается на <code>watch:</code></p>
<p>Теперь, в терминале запустим команду:</p>
<pre><code>npm run dev
</code></pre>
<p>Файл <code>src/index.scss</code> будет откомпилирован в <code>dist/index.css</code>, у которого внутри будет следующее:</p>
<pre><code class="language-css">html {
  font-size: 1rem;
  color: rgb(146, 0, 17);
  color: color(display-p3 0.54534 0 0.06183);
}

.example {
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}
</code></pre>
<p>Для того, чтобы наши стили отобразились на странице, добавим в основной шаблон <code>src/layouts/base/index.pug</code> ссылку на откомпилированный <code>dist/index.css</code></p>
<pre><code class="language-pug">-
  let data = {
    default_description: &quot;Показан пример общего шаблона Pug для всех страниц&quot;,
    default_title: &quot;Общий шаблон Pug&quot;
  }

- const {default_title, default_description} = data

doctype html
html(lang='ru')
  head
    meta(charset='utf-8')
    meta(name='viewport' content='width=device-width, initial-scale=1.0')
+   link(rel='stylesheet' href='index.css')

    meta(name= 'description' content= description ? description : default_description)
    title= title ? title : default_title

  body
    block main
</code></pre>
<p>Сохраним изменения и мы увидим, что страница браузера обновилась со стилевым оформлением заголовка:</p>
<p><img src="title-styling.png" alt="Стилизация заголовка"></p>
<h2>Установка и настройка пакетного конвертера md-pug-to-html</h2>
<p>Все более распространенным способом написания статей является язык разметки <a href="https://daringfireball.net/projects/markdown/">Markdown</a>. Статья пишется на Markdown и сохраняется в файле с расширением <code>.md</code>. Если же в статье нужно поместить рисунки, то удобнее всего создать каталог и поместить в него статью и рисунки. Для каждой статьи создается свой каталог, а каталоги статей объединяются в каталоги по темам.</p>
<p>Теперь, нам нужен пакетный конвертер, который сможет сканировать эти каталоги, искать файлы Markdown, преобразовать их в Html страницы и помещать в каталог сайта с сохранением исходной структуры каталогов. Также нужно, чтобы изображения к статьям были перемещены в нужные места. При этом, Html страницы должны конвертироваться согласно заданному шаблону Pug.</p>
<p>Для вышеописанной задачи мне не удалось найти ничего подходящего в репозитории NPM. Наверное, плохо искал. Поэтому, я создал свой пакетный конвертер <a href="https://www.npmjs.com/package/md-pug-to-html">MdPugToHtml</a>.</p>
<p>Установим этот пакет в нашем проекте</p>
<pre><code>npm i -D md-pug-to-html
</code></pre>
<p>Для конвертера MdPugToHtml написана подробная справка как на <a href="https://github.com/injashkin/md-pug-to-html/blob/main/README.ru.md">русском</a>, так и на <a href="https://github.com/injashkin/md-pug-to-html/blob/main/README.md">английском</a> языках. Здесь мы рассмотрим, как пользоваться этим пакетом в нашем конкретном случае.</p>
<p>Для начала создадим каталог с файлами Markdown. В корневом каталоге проекта создадим каталог <code>content</code>, а в нем еще пару каталогов <code>article1</code> и <code>article2</code>. Каждому такому каталогу нужно давать имена, отражающие название статьи. Они потом будут отображаться в ЧПУ. В каждом таком каталоге будет хранится одна статья и сопутствующие ей файлы изображений если они присутствуют. Сам файл статьи лучше называть везде одинаково - <code>index.md</code>.</p>
<p>Создадим файл <code>content/article1/index.md</code> для первой статьи и запишем в него следующее:</p>
<pre><code>---
title: Статья первая
description: Краткое описание первой статьи
create: 10-08-2022
---

## Заголовок h2 в первой статье
</code></pre>
<p>Создадим файл <code>content/article2/index.md</code> для второй статьи и запишем в него следующее:</p>
<pre><code>---
title: Статья вторая
description: Краткое описание второй статьи
create: 11-08-2022
---

## Заголовок h2 во второй статье
</code></pre>
<p>Блок данных, указанный в начале каждого файла называется Frontmatter, имеет формат YAML/TOML/JSON и отделяется с двух сторон тремя дефисами ---.</p>
<p>Frontmatter не является стандартом для Markdown и не распознается многими конвертерами. Однако конвертер MdPugToHtml умеет распознавать и обрабатывать Frontmatter благодаря пакету <a href="https://www.npmjs.com/package/gray-matter">gray-matter</a>, который встроен в пакет MdPugToHtml в качестве зависимости.</p>
<p>В файле package.json настроим MdPugToHtml</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;clean&quot;: &quot;rimraf dist tmp&quot;,
+   &quot;md-pug-to-html&quot;: &quot;md-pug-to-html content -o dist -t src/pages/article&quot;,
    &quot;pug&quot;: &quot;pug --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;watch:pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
    &quot;sass&quot;: &quot;node-sass src/index.scss -o tmp&quot;,
    &quot;watch:sass&quot;: &quot;node-sass -w src/index.scss -o tmp&quot;,
    &quot;watch:post&quot;: &quot;postcss -w tmp -d dist -u postcss-preset-env&quot;,
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
+   &quot;dev&quot;: &quot;npm-run-all clean md-pug-to-html pug sass -p watch:*&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>Здесь мы указали в качестве аргумента каталог <code>content</code>, где расположены файлы Markdown, с помощью опции <code>-o</code> указываем каталог сборки проекта <code>dist</code>, а с помощью опции <code>-t</code> - каталог <code>src/pages/article</code>, где расположен шаблон Pug для этих страниц. Так как у нас еще нет такого шаблона, то мы его можем создать самостоятельно. При этом имя файла шаблона должно быть <code>mpth-template.pug</code>.</p>
<p>Для этого, в каталоге <code>src/pages</code> создадим каталог <code>article</code>, в котором создадим файл <code>mpth-template.pug</code> со следующим содержимым:</p>
<pre><code class="language-pug">extends ../../layouts/base/index

block main
  .content
    .article
      h1= data.title
      .creationDate= `Создано: ${data.create}`
      != contentHtml
</code></pre>
<p>Теперь выполним команду:</p>
<pre><code>npm run dev
</code></pre>
<p>Закроем открывшееся окно браузера и перейдем в каталог <code>dist</code>. Здесь мы увидим три новых каталога <code>article1</code>, <code>article2</code> и <code>images</code>. В первых двух расположены страницы HTML, а каталог <code>images</code> пуст, в него будут копироваться файлы изображений.</p>
<p>Если мы перейдем в каталог <code>src</code>, то увидим новый каталог <code>data</code>, в котором находится файл <code>mpth-data.pug</code>. Этот файл содержит массив объектов с URL адресами, заголовками и кратким описанием для каждой созданной статьи:</p>
<pre><code class="language-pug">- const dataListItems = [{&quot;pathFile&quot;:&quot;article1/&quot;,&quot;title&quot;:&quot;Статья первая&quot;,&quot;description&quot;:&quot;Краткое описание первой статьи&quot;},{&quot;pathFile&quot;:&quot;article2/&quot;,&quot;title&quot;:&quot;Статья вторая&quot;,&quot;description&quot;:&quot;Краткое описание второй статьи&quot;}]
</code></pre>
<p>Этот файл мы будем использовать в компоненте, который будет отображать список ссылок на статьи. Для этого в каталоге <code>src/components</code> создадим каталог <code>list-articles</code>, а в нем создадим файл <code>index.pug</code>, в который скопируем код миксина:</p>
<pre><code class="language-pug">mixin list-articles

  include ../../data/mpth-data.pug
  ul.list__box
    each item in dataListItems
      li
        a.list__item(href=item.pathFile)= item.title
        p= item.description
</code></pre>
<p>Теперь откроем файл <code>src/pages/home/index.pug</code> и подключим в него созданный выше миксин с помощью <code>include ../../components/list-articles/index</code>, а затем пропишем его вызов <code>+list-articles</code>:</p>
<pre><code class="language-pug">extends ../../layouts/base/index
include ../../components/button/button
include ../../components/list-articles/index

block main
  h1.name= 'Код написан с помощью разметки Pug!'
  +button
  +list-articles
</code></pre>
<p>Перейдем в браузер с нашей страницей, где мы увидим список ссылок на статьи с кратким описанием:</p>
<p><img src="list-articles.png" alt="Список статей"></p>
<p>При нажатии на любую из ссылок мы перейдем на соответствующую страницу со статьей.</p>
<h2>Установка и настройка сборщика Rollup</h2>
<p>Для сборки JavaScript файлов будем применять сборщик <a href="https://www.npmjs.com/package/rollup">Rollup</a>. Он будет объединять JavaScript модули в один файл <code>index.js</code>. Установим Rollup:</p>
<pre><code>npm i -D rollup
</code></pre>
<p>Для демонстрации работы сборщика Rollup создадим файл <code>src/components/button/button.js</code> и напишем в нем функцию, которая будет изменять текст на кнопке:</p>
<pre><code class="language-js">export function button() {
  let button = document.querySelector('.button');
  let text = button.textContent;
  const message = &quot;Этот текст изменен JavaScript'ом&quot;;

  button.addEventListener('click', () =&gt; {
    text === message ? (text = 'Жми еще!') : (text = message);
    button.textContent = text;
  });
}
</code></pre>
<p>Затем, создадим главный файл скрипта <code>src/index.js</code>, в который сделаем импорт вышеуказанного модуля и вызов функции:</p>
<pre><code class="language-js">import { button } from './components/button/button.js';

button();
</code></pre>
<p>Теперь в главном шаблоне нашего проекта <code>src/layouts/base/index.pug</code> укажем, где будет расположен собранный сборщиком Rollup скрипт <code>index.js</code>. Он будет находится в каталоге <code>dist</code>. Так как это каталог сборки проекта, и, следовательно он будет корневым каталогом будущего сайта, то мы указываем, просто, имя файла <code>script(defer src='index.js')</code>. <code>defer</code> мы указали, чтобы скрипт запустился после построения дерева DOM.</p>
<pre><code class="language-pug">-
  let data = {
    default_description: &quot;Показан пример общего шаблона Pug для всех страниц&quot;,
    default_title: &quot;Общий шаблон Pug&quot;
  }

- const {default_title, default_description} = data

doctype html
html(lang='ru')
  head
    meta(charset='utf-8')
    meta(name='viewport' content='width=device-width, initial-scale=1.0')
    link(rel='stylesheet' href='index.css')

    script(defer src='index.js')

    meta(name= 'description' content= description ? description : default_description)
    title= title ? title : default_title

  body
    block main
</code></pre>
<p>Добавим в файл <code>package.json</code> скрипт запуска для Rollup:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;clean&quot;: &quot;rimraf dist tmp&quot;,
    &quot;md-pug-to-html&quot;: &quot;md-pug-to-html -i=content -o=dist -t=src/pages/article&quot;,
    &quot;pug&quot;: &quot;pug --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;watch:pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
    &quot;sass&quot;: &quot;node-sass src/index.scss -o tmp&quot;,
    &quot;watch:sass&quot;: &quot;node-sass -w src/index.scss -o tmp&quot;,
    &quot;watch:post&quot;: &quot;postcss -w tmp -d dist -u postcss-preset-env&quot;,
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
+   &quot;watch:rollup&quot;: &quot;rollup -w -c rollup.config.js&quot;,
    &quot;dev&quot;: &quot;npm-run-all clean md-pug-to-html pug sass -p watch:*&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>В скрипте <code>&quot;watch:rollup&quot;</code> параметр <code>-w</code> (или<code>--watch</code>) сообщает сборщику, что он должен работать в режиме наблюдения, а параметр <code>-c</code> (или <code>--config</code>) говорит, что есть файл настроек и имя ему <code>rollup.config.js</code>.</p>
<p>Раз указан файл настроек <code>rollup.config.js</code>, то создадим его в корне проекта и напишем в нем следующее:</p>
<pre><code class="language-js">export default {
  input: 'src/index.js',

  watch: {
    include: './src/**',
    clearScreen: false,
  },

  output: {
    file: 'dist/index.js',
    format: 'iife',
  },
};
</code></pre>
<p>Свойство <code>input</code> указывает путь к главному скрипту проекта, с которого Rollup начнет собирать все скрипты в один конечный файл-бандл. Адрес этого бандла указан в свойстве <code>file</code> объекта <code>output</code>. В этом же объекте свойство <code>format</code> указывает на формат вывода файла. Здесь указан формат <code>'iife'</code>, что превращает код выходного файла в <a href="https://benalman.com/news/2010/11/immediately-invoked-function-expression/">немедленно вызываемую функцию</a> (IIFE). Более подробно о параметре <code>format</code> <a href="https://rollupjs.org/guide/en/#outputformat">см. документацию</a>.</p>
<p>Для режима наблюдения существует множество настроек. Ознакомиться с ними можно в <a href="https://rollupjs.org/guide/en/#watch-options">документации</a>. В нашем же файле свойство <code>include</code> ограничивает область наблюдения каталогом <code>src</code>, а свойство <code>clearScreen</code> запрещает очистку экрана при перезапуске сборщика Rollup.</p>
<p>Сохраним все изменения и перезапустим проект</p>
<pre><code>npm run dev
</code></pre>
<p>Откроется окно браузера, в котором при нажатии на кнопку будет изменяться текст на ней. При первом нажатии текст <code>Код написан с помощью разметки Pug</code> будет заменен на <code>Этот текст изменен JavaScript'ом</code>, при втором нажатии текст изменится на <code>Жми еще!</code>.</p>
<h2>Оптимизация изображений</h2>
<p>Одной из главных причин медленной загрузки сайта является большой объем контента с изображениями. Для того, чтобы сайт загружался быстрее нужно максимально оптимизировать эти изображения. Оптимизация изображений подразумевает, как минимум, уменьшение размера файлов при сохранении визуального качества. Чтобы не заниматься этим вручную мы автоматизируем этот процесс. Для автоматического сжатия можно использовать такие инструменты как ImageMagick, <a href="https://github.com/jcupitt/libvips">libvips</a> или <a href="https://github.com/imagemin/imagemin-cli">imagemin</a>. Мы воспользуемся последним.</p>
<h3>Установка и настройка модуля imagemin</h3>
<p>Imagemin — популярный модуль сжатия изображений.</p>
<p>Установим <code>imagemin-cli</code>:</p>
<pre><code>npm i -D imagemin-cli
</code></pre>
<p>Добавим в файл <code>package.json</code> следующий код:</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;clean&quot;: &quot;rimraf dist tmp&quot;,
    &quot;md-pug-to-html&quot;: &quot;md-pug-to-html -i=content -o=dist -t=src/pages/article&quot;,
    &quot;pug&quot;: &quot;pug --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;watch:pug&quot;: &quot;pug --pretty -w src/pages/home/index.pug -o dist&quot;,
    &quot;sass&quot;: &quot;node-sass src/index.scss -o tmp&quot;,
    &quot;watch:sass&quot;: &quot;node-sass -w src/index.scss -o tmp&quot;,
    &quot;watch:post&quot;: &quot;postcss -w tmp -d dist -u postcss-preset-env&quot;,
+   &quot;img&quot;: &quot;imagemin src/pages/**/images src/images -o dist/images&quot;,
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
    &quot;watch:rollup&quot;: &quot;rollup -w -c rollup.config.js&quot;,
+   &quot;dev&quot;: &quot;npm-run-all clean pug sass img -p watch:*&quot;,
    &quot;build&quot;: &quot;echo \&quot;There's nothing yet, but you can contribute\&quot; &amp;&amp; exit 1&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>Скрипт <code>&quot;img&quot;</code> указывает <code>imagemin</code> найти и сжать все изображения в каталогах <code>src/pages/**/images</code> и <code>src/images</code> и поместить их в <code>dist/images</code>. Более подробные настройки можно посмотреть в <a href="https://github.com/imagemin/imagemin-cli#usage">документации</a>.</p>
<h3>Установка и настройка модуля SVGO</h3>
<p>Обычно, SVG изображения содержат избыточный код, который любят оставлять редакторы графики. <a href="https://github.com/svg/svgo">SVGO</a> минимизирует файлы SVG удаляя тот самый ненужный код. Существует онлайн инструмент по оптимизации SVG файлов и кода - <a href="https://jakearchibald.github.io/svgomg/">SVGOMG</a>. Также, существуют плагины: для PostCSS - <a href="https://www.npmjs.com/package/postcss-svgo">postcss-svgo</a>; для Rollup - <a href="https://github.com/porsager/rollup-plugin-svgo">rollup-plugin-svgo</a>.</p>
<p>Мы будем использовать SVGO, который можно <a href="https://www.npmjs.com/package/svgo">установить как CLI</a>:</p>
<p>npm i -D svgo</p>
<p>Настроим <code>package.json</code>:</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  ...
  &quot;watch:svg&quot;: &quot;svgo -f src/assets/svg -o dist/svg&quot;,
  ...
}
</code></pre>
<p>Флаг <code>-f</code> (или <code>--folder</code>) указывает, что будут обрабатываться не отдельные файлы, а каталог, что все файлы с расширением <code>.svg</code> будут взяты из каталога <code>src/assets/svg</code>, оптимизированы и помещены в каталог <code>dist/svg</code>, который будет создан при его отсутствии.</p>
<p>Создадим каталог <code>src/assets/svg</code> и поместим туда несколько файлов <code>.svg</code>, взять их можно <a href="https://fonts.google.com/icons?selected=Material+Icons&amp;icon.set=Material+Symbols&amp;icon.query=wh">здесь</a>. Если мы скачаем значок <code>email_black_24dp</code> в виде файла SVG и откроем этот файл в любом текстовом редакторе, то мы увидим следующее:</p>
<pre><code class="language-xml">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot; fill=&quot;#000000&quot;&gt;&lt;path d=&quot;M0 0h24v24H0V0z&quot; fill=&quot;none&quot;/&gt;&lt;path d=&quot;M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.4 4.25l-7.07 4.42c-.32.2-.74.2-1.06 0L4.4 8.25c-.25-.16-.4-.43-.4-.72 0-.67.73-1.07 1.3-.72L12 11l6.7-4.19c.57-.35 1.3.05 1.3.72 0 .29-.15.56-.4.72z&quot;/&gt;&lt;/svg&gt;
</code></pre>
<p>Чтобы значок гибко подстраивался под размер шрифта заменим значения атрибутов <code>height</code> и <code>width</code> с <code>24px</code> на <code>1em</code>:</p>
<pre><code class="language-xml">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;1em&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;1em&quot; fill=&quot;#000000&quot;&gt;&lt;path ....
</code></pre>
<p>и сохраним этот файл. То же самое проделаем с другими файлами.</p>
<p>Затем в файл <code>src/pages/home/index.pug</code> добавим следующее:</p>
<pre><code class="language-pug">extends ../../layouts/base/index
include ../../components/button/button
include ../../components/list-articles/index

block main
  h1.name= 'Код написан с помощью разметки Pug!'
  +button
  p.text= 'Нажми кнопку'
  +list-articles
  img(src='images/built-with.png')
+ p.text= 'Если что-то не так, звони по телефону:'
+ a.phone-link(href='tel:+79189999999')
+   img.icon-phone(src='svg/phone_black_24dp.svg')
+   .phone-number='+79189999999'
</code></pre>
<p>В конец уже существующего файла <code>src/index.scss</code> добавим следующие стили:</p>
<pre><code class="language-scss">.phone-link {
  display: flex;
  text-decoration: none;
  color: $font-color;
}

.icon-phone {
  width: 2.5 * $font-size;
  height: 2.5 * $font-size;
}

.phone-number {
  font-size: 2.4 * $font-size;
}
</code></pre>
<p>Запустим сборку:</p>
<pre><code>npm run dev
</code></pre>
<p>В окне браузера в самом низу мы увидим следующее:</p>
<p><img src="phone-svg-image.png" alt="SVG значок телефона"></p>
<h2>Установка и настройка генератора спрайтов svg-sprite-generator</h2>
<p><a href="https://www.npmjs.com/package/svg-sprite-generator">svg-sprite-generator</a> - генератор SVG-спрайтов, который из отдельных файлов SVG создает один файл-спрайт.</p>
<p>Установим пакет:</p>
<pre><code>npm i -D svg-sprite-generator
</code></pre>
<p>Напишем настройки в <code>package.json</code></p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;clean&quot;: &quot;rimraf dist tmp&quot;,
    &quot;pug&quot;: &quot;pug --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;watch:pug&quot;: &quot;pug -w --pretty src/pages/home/index.pug -o dist&quot;,
    &quot;sass&quot;: &quot;node-sass src/pages/home/index.scss -o tmp&quot;,
    &quot;watch:sass&quot;: &quot;node-sass -w src/pages/home/index.scss -o tmp&quot;,
+   &quot;watch:svg&quot;: &quot;svgo -f src/assets/svg -o dist/svg &amp;&amp; svg-sprite-generate -d dist/svg -o dist/svg/sprite.svg&quot;,
    &quot;watch:post&quot;: &quot;postcss -w tmp/index.css -d dist -u postcss-preset-env&quot;,
    &quot;img&quot;: &quot;imagemin src/pages/**/images/* src/images/* -o dist/images&quot;,
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
    &quot;watch:rollup&quot;: &quot;rollup --watch -c rollup.config.js&quot;,
    &quot;dev&quot;: &quot;npm-run-all clean pug sass img -p watch:*&quot;,
    &quot;build&quot;: &quot;echo \&quot;There's nothing yet, but you can contribute\&quot; &amp;&amp; exit 1&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
</code></pre>
<p>С помощью цепочки из операторов <code>&amp;&amp;</code> можно последовательно запускать различные скрипты. Так в скрипте <code>&quot;watch:svg&quot;</code> мы добавим через <code>&amp;&amp;</code> другой скрипт. Это значит, что после успешного выполнения кода <code>-f src/assets/svg -o dist/svg</code> будет выполнен код <code>svg-sprite-generate -d dist/svg -o dist/svg/sprite.svg</code>, который означает, что все файлы с расширением <code>.svg</code> будут взяты из каталога <code>dist/svg</code>, объединены в спрайт <code>sprite.svg</code> и этот спрайт будет помещен в этот же каталог.</p>
<p>Выполним сборку всего проекта:</p>
<pre><code>npm run dev
</code></pre>
<p>Мы обнаружим в каталоге <code>dist/svg/</code> новый файл <code>sprite.svg</code>. Спрайт внутри выглядит, примерно, так:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
  &lt;symbol id=&quot;email_black_24dp&quot;&gt;
    &lt;path d=&quot;M0 0h24v24H0V0z&quot; fill=&quot;none&quot; /&gt;&lt;path d=&quot;M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2...&quot; /&gt;
  &lt;/symbol&gt;
  &lt;symbol id=&quot;phone_black_24dp&quot;&gt;
    &lt;path d=&quot;M0 0h24v24H0V0z&quot; fill=&quot;none&quot; /&gt;&lt;path d=&quot;m19.23 15.26-2.54-.29a1.99 1.99 0 0 0-1.64.57l-1.84 1.84a15.045 15.045 0 0 1-6.59-...&quot; /&gt;
  &lt;/symbol&gt;
  &lt;symbol id=&quot;whatsapp_black_24dp&quot;&gt;
    &lt;path d=&quot;M0 0h24v24H0z&quot; /&gt;&lt;g fill=&quot;none&quot;&gt;&lt;path d=&quot;M0 0h24v24H0z&quot; /&gt;&lt;/g&gt;&lt;path d=&quot;M19.05 4.91A9.816 9.816 0 0 0 12.04 2c-5.46 0-9.91 4.45-9.91 9...&quot; /&gt;
  &lt;/symbol&gt;
&lt;/svg&gt;
</code></pre>
<p>Здесь в один спрайт упаковано три файла SVG. Код каждого отдельного файла SVG заключен между тегами <code>&lt;symbol&gt;</code>, а это значит, что значки не будут отображаться если мы попробуем вызвать отдельный элемент спрайта вот так: <code>&lt;img src=&quot;svg/sprite.svg#email_black_24dp&quot;/&gt;</code>. Отобразить нужный значок можно, если его вызвать с помощью команды <code>&lt;use&gt;</code> по уникальному идентификатору. Соответственно, тэг <code>&lt;use&gt;</code> должен быть обернут тегом <code>&lt;svg&gt;</code>. Отобразим какой-нибудь значок из спрайта, для этого добавим в конец файла <code>src/pages/home/index.pug</code> следующий код:</p>
<pre><code class="language-pug">  p.text= 'или пиши на почту:'
  a.email-link(href='mailto:info@jinv.ru' title='Написать письмо')
    svg.icon(role='img')
      use(href='svg/sprite.svg#email_black_24dp')
    .email-address='info@jinv.ru'
</code></pre>
<p>Стилизуем данный код в файле <code>src/index.scss</code>:</p>
<pre><code class="language-scss">.email-link {
  display: flex;
  text-decoration: none;
  color: $font-color;

  &amp;:hover {
    text-decoration: underline;
    background-color: bisque;
  }
}

.icon {
  width: 2.5 * $font-size;
  height: 2.5 * $font-size;
}

.email-address {
  font-size: 2 * $font-size;
}
</code></pre>
<p>Запустим сборку:</p>
<pre><code>npm run dev
</code></pre>
<p>В окне браузера в самом низу мы увидим следующее:</p>
<p><img src="phone-svg-image.png" alt="SVG значок email"></p>
<h2>Копирование файлов и каталогов</h2>
<p>Часто возникает необходимость скопировать некоторые файлы или даже каталоги в сборку проекта без их преобразования. Для примера возьмем файл <code>robots.txt</code>, который используется для ограничения доступа поисковым роботам к определенным ресурсам сайта.</p>
<p>Создадим в корне проекта каталог <code>static</code>, в котором создадим файл <code>robots.txt</code> со следующим содержимым:</p>
<pre><code class="language-txt">User-agent: *
Disallow:
Disallow: /404.html
Allow: /
Sitemap: https://jinv.ru/sitemap/sitemap-index.xml
Host: https://jinv.ru
</code></pre>
<p>Данный файл должен без изменений попасть в корень сайта, а так как корневым каталогом будущего сайта является каталог <code>dist</code>, то файл <code>robots.txt</code> должен копироваться в этот каталог при каждой сборке проекта.</p>
<p>Установим fse-cli:</p>
<pre><code>npm i -D @atao60/fse-cli
</code></pre>
<p>Пакет <code>fse-cli</code> является интерфейсом командной строки для <code>fs-extra</code>, который, в свою очередь, расширяет стандартный модуль <code>fs</code> дополнительными методами для работы с файловой системой.</p>
<p>Обычно файл <code>robots.txt</code> и другие подобные ему ресурсы не используются на этапе разработки, а нужны только в готовой сборке. Поэтому, мы настроим <code>package.json</code> для <code>fse-cli</code> следующим образом:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    ...
    &quot;watch:serve&quot;: &quot;browser-sync dist -w&quot;,
    &quot;watch:rollup&quot;: &quot;rollup -w -c rollup.config.js&quot;,
    &quot;build:rollup&quot;: &quot;rollup -c rollup.config.js&quot;,
+   &quot;copy&quot;: &quot;fse copy static dist&quot;,
    &quot;dev&quot;: &quot;npm-run-all clean md-pug-to-html pug sass img -p watch:*&quot;,
+   &quot;build&quot;: &quot;npm-run-all clean md-pug-to-html build:pug sass build:svg build:post img build:rollup copy&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  }
</code></pre>
<p>После того, как мы выполним команду сборки проекта:</p>
<pre><code>npm run build
</code></pre>
<p>Содержимое каталога <code>static</code> будет скопировано в каталог <code>dist</code>. Обратите внимание, сам каталог <code>static</code> не копируется.</p>
<p>Данная статья не является законченной. Она будет пополняться и изменяться по мере развития проекта <a href="https://github.com/injashkin/npm-for-frontend">npm-for-frontend</a></p>

      </div>
    </div>
    <footer class="footer"> 
      <div class="footer__content content">
        <div class="footer__contacts" id="contacts"> <a class="footer__email-link" href="mailto:injashkin@gmail.com" title="Написать письмо">
            <svg class="icon icon__undefined" role="img" width="1em" height="1em">
              <use href="/sprite.svg#undefined"></use>
            </svg>
            <div class="footer__email">injashkin@gmail.com</div></a></div>
        <div class="footer__developer"> <a href="http://jinv.ru" target="_blank">Разработка сайта jinv.ru</a></div>
        <div class="footer__copyright-wrap">
          <div class="footer__copyright">jinv.ru © 2019 - 2022</div>
        </div>
      </div>
    </footer><!-- Yandex.Metrika counter -->
<script type="text/javascript">
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function () {
      try {
        w.yaCounter60672532 = new Ya.Metrika({
          id: 60672532,
          clickmap: true,
          trackLinks: true,
          accurateTrackBounce: true,
        });
      } catch (e) {}
    });

    var n = d.getElementsByTagName('script')[0],
      x = 'https://mc.yandex.ru/metrika/watch.js',
      s = d.createElement('script'),
      f = function () {
        n.parentNode.insertBefore(s, n);
      };
    for (var i = 0; i < document.scripts.length; i++) {
      if (document.scripts[i].src === x) {
        return;
      }
    }
    s.type = 'text/javascript';
    s.async = true;
    s.src = x;

    if (w.opera == '[object Opera]') {
      d.addEventListener('DOMContentLoaded', f, false);
    } else {
      f();
    }
  })(document, window, 'yandex_metrika_callbacks');
</script>
<noscript
  ><div>
    <img
      src="https://mc.yandex.ru/watch/60672532"
      style="position: absolute; left: -9999px"
      alt=""
    /></div
></noscript>
<!-- /Yandex.Metrika counter -->

  </body>
</html>